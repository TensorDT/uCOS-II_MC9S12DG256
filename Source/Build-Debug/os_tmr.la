   1                     ; C Compiler for 68HCS12 [COSMIC Software]
   2                     ; Parser V4.11.9 - 08 Feb 2017
   3                     ; Generator V4.8.12 - 22 Feb 2017
   4                     ; Optimizer V4.7.11 - 22 Feb 2017
4172                     ; 121 _NEAR OS_TMR  *OSTmrCreate (INT32U           dly,
4172                     ; 122                            INT32U           period,
4172                     ; 123                            INT8U            opt,
4172                     ; 124                            OS_TMR_CALLBACK  callback,
4172                     ; 125                            void            *callback_arg,
4172                     ; 126                            INT8U           *pname,
4172                     ; 127                            INT8U           *perr)
4172                     ; 128 {
4173                     	switch	.text
4174 fb00c               _OSTmrCreate:
4176 fb00c 3b            	pshd	
4177 fb00d 34            	pshx	
4178 fb00e 3b            	pshd	
4179       00000002      OFST:	set	2
4182                     ; 148     switch (opt) {                                          /* Validate arguments                                     */
4184 fb00f e68d          	ldab	OFST+11,s
4186 fb011 04011a        	dbeq	b,L1662
4187 fb014 040104        	dbeq	b,L7562
4188                     ; 163         default:
4188                     ; 164              *perr = OS_ERR_TMR_INVALID_OPT;
4190 fb017 c684          	ldab	#132
4191                     ; 165              return ((OS_TMR *)0);
4194 fb019 200a          	bra	LC001
4195 fb01b               L7562:
4196                     ; 149         case OS_TMR_OPT_PERIODIC:
4196                     ; 150              if (period == 0u) {
4198 fb01b ec88          	ldd	OFST+6,s
4199 fb01d 261b          	bne	L1003
4200 fb01f ec8a          	ldd	OFST+8,s
4201 fb021 2617          	bne	L1003
4202                     ; 151                  *perr = OS_ERR_TMR_INVALID_PERIOD;
4204 fb023 c683          	ldab	#131
4205                     ; 152                  return ((OS_TMR *)0);
4207 fb025               LC001:
4208 fb025 6bf30014      	stab	[OFST+18,s]
4209 fb029 87            	clra	
4210 fb02a c7            	clrb	
4212 fb02b               L21:
4214 fb02b 1b86          	leas	6,s
4215 fb02d 3d            	rts	
4216 fb02e               L1662:
4217                     ; 156         case OS_TMR_OPT_ONE_SHOT:
4217                     ; 157              if (dly == 0u) {
4219 fb02e ec82          	ldd	OFST+0,s
4220 fb030 2608          	bne	L1003
4221 fb032 ec84          	ldd	OFST+2,s
4222 fb034 2604          	bne	L1003
4223                     ; 158                  *perr = OS_ERR_TMR_INVALID_DLY;
4225 fb036 c682          	ldab	#130
4226                     ; 159                  return ((OS_TMR *)0);
4229 fb038 20eb          	bra	LC001
4230 fb03a               L1003:
4231                     ; 168     if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
4233 fb03a f6163c        	ldab	_OSIntNesting
4234 fb03d 2704          	beq	L7003
4235                     ; 169         *perr  = OS_ERR_TMR_ISR;
4237 fb03f c68b          	ldab	#139
4238                     ; 170         return ((OS_TMR *)0);
4241 fb041 20e2          	bra	LC001
4242 fb043               L7003:
4243                     ; 172     OSSchedLock();
4245 fb043 1644b4        	jsr	_OSSchedLock
4247                     ; 173     ptmr = OSTmr_Alloc();                                   /* Obtain a timer from the free pool                      */
4249 fb046 167326        	jsr	L3462_OSTmr_Alloc
4251 fb049 6c80          	std	OFST-2,s
4252                     ; 174     if (ptmr == (OS_TMR *)0) {
4254 fb04b 2607          	bne	L1103
4255                     ; 175         OSSchedUnlock();
4257 fb04d 1644d8        	jsr	_OSSchedUnlock
4259                     ; 176         *perr = OS_ERR_TMR_NON_AVAIL;
4261 fb050 c686          	ldab	#134
4262                     ; 177         return ((OS_TMR *)0);
4265 fb052 20d1          	bra	LC001
4266 fb054               L1103:
4267                     ; 179     ptmr->OSTmrState       = OS_TMR_STATE_STOPPED;          /* Indicate that timer is not running yet                 */
4269 fb054 c601          	ldab	#1
4270 fb056 ed80          	ldy	OFST-2,s
4271 fb058 6be816        	stab	22,y
4272                     ; 180     ptmr->OSTmrDly         = dly;
4274 fb05b 1802844f      	movw	OFST+2,s,15,y
4275 fb05f 1802824d      	movw	OFST+0,s,13,y
4276                     ; 181     ptmr->OSTmrPeriod      = period;
4278 fb063 ec8a          	ldd	OFST+8,s
4279 fb065 6ce813        	std	19,y
4280 fb068 ec88          	ldd	OFST+6,s
4281 fb06a 6ce811        	std	17,y
4282                     ; 182     ptmr->OSTmrOpt         = opt;
4284 fb06d e68d          	ldab	OFST+11,s
4285 fb06f 6be815        	stab	21,y
4286                     ; 183     ptmr->OSTmrCallback    = callback;
4288 fb072 18028e41      	movw	OFST+12,s,1,y
4289                     ; 184     ptmr->OSTmrCallbackArg = callback_arg;
4291 fb076 ecf010        	ldd	OFST+14,s
4292 fb079 6c43          	std	3,y
4293                     ; 192     OSSchedUnlock();
4295 fb07b 1644d8        	jsr	_OSSchedUnlock
4297                     ; 194     *perr = OS_ERR_NONE;
4300 fb07e 69f30014      	clr	[OFST+18,s]
4301                     ; 195     return (ptmr);
4303 fb082 ec80          	ldd	OFST-2,s
4305 fb084 20a5          	bra	L21
4356                     ; 225 _NEAR BOOLEAN  OSTmrDel (OS_TMR  *ptmr,
4356                     ; 226                         INT8U   *perr)
4356                     ; 227 {
4357                     	switch	.text
4358 fb086               _OSTmrDel:
4360       00000000      OFST:	set	0
4363                     ; 244     if (ptmr == (OS_TMR *)0) {
4365 fb086 6cae          	std	2,-s
4366 fb088 2609          	bne	L7403
4367                     ; 245         *perr = OS_ERR_TMR_INVALID;
4369 fb08a c68a          	ldab	#138
4370 fb08c 6bf30004      	stab	[OFST+4,s]
4371                     ; 246         return (OS_FALSE);
4373 fb090 c7            	clrb	
4376 fb091 31            	puly	
4377 fb092 3d            	rts	
4378 fb093               L7403:
4379                     ; 252     if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
4382 fb093 e6f30000      	ldab	[OFST+0,s]
4383 fb097 c164          	cmpb	#100
4384 fb099 2709          	beq	L1503
4385                     ; 253         *perr = OS_ERR_TMR_INVALID_TYPE;
4387 fb09b c689          	ldab	#137
4388 fb09d 6bf30004      	stab	[OFST+4,s]
4389                     ; 255         return (OS_FALSE);
4392 fb0a1 c7            	clrb	
4395 fb0a2 31            	puly	
4396 fb0a3 3d            	rts	
4397 fb0a4               L1503:
4398                     ; 257     if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
4400 fb0a4 f6163c        	ldab	_OSIntNesting
4401 fb0a7 2709          	beq	L3503
4402                     ; 258         *perr  = OS_ERR_TMR_ISR;
4404 fb0a9 c68b          	ldab	#139
4405 fb0ab 6bf30004      	stab	[OFST+4,s]
4406                     ; 260         return (OS_FALSE);
4409 fb0af c7            	clrb	
4412 fb0b0 31            	puly	
4413 fb0b1 3d            	rts	
4414 fb0b2               L3503:
4415                     ; 262     OSSchedLock();
4417 fb0b2 1644b4        	jsr	_OSSchedLock
4419                     ; 263     switch (ptmr->OSTmrState) {
4421 fb0b5 ed80          	ldy	OFST+0,s
4422 fb0b7 e6e816        	ldab	22,y
4424 fb0ba 273a          	beq	L7103
4425 fb0bc 040127        	dbeq	b,L5103
4426 fb0bf 040124        	dbeq	b,L5103
4427 fb0c2 04010c        	dbeq	b,L3103
4428                     ; 286         default:
4428                     ; 287              OSSchedUnlock();
4430 fb0c5 1644d8        	jsr	_OSSchedUnlock
4432                     ; 288              *perr = OS_ERR_TMR_INVALID_STATE;
4434 fb0c8 c68d          	ldab	#141
4435 fb0ca 6bf30004      	stab	[OFST+4,s]
4436                     ; 290              return (OS_FALSE);
4439 fb0ce c7            	clrb	
4442 fb0cf 31            	puly	
4443 fb0d0 3d            	rts	
4444 fb0d1               L3103:
4445                     ; 264         case OS_TMR_STATE_RUNNING:
4445                     ; 265              OSTmr_Unlink(ptmr);                            /* Remove from current wheel spoke                        */
4447 fb0d1 b764          	tfr	y,d
4448 fb0d3 1674ce        	jsr	L3562_OSTmr_Unlink
4450                     ; 266              OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
4452 fb0d6 ec80          	ldd	OFST+0,s
4453 fb0d8 16734f        	jsr	L5462_OSTmr_Free
4455                     ; 267              OSSchedUnlock();
4457 fb0db 1644d8        	jsr	_OSSchedUnlock
4459                     ; 268              *perr = OS_ERR_NONE;
4461 fb0de 69f30004      	clr	[OFST+4,s]
4462                     ; 270              return (OS_TRUE);
4465 fb0e2 c601          	ldab	#1
4468 fb0e4 31            	puly	
4469 fb0e5 3d            	rts	
4470 fb0e6               L5103:
4471                     ; 272         case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
4471                     ; 273         case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
4471                     ; 274              OSTmr_Free(ptmr);                              /* Return timer to free list of timers                    */
4473 fb0e6 b764          	tfr	y,d
4474 fb0e8 16734f        	jsr	L5462_OSTmr_Free
4476                     ; 275              OSSchedUnlock();
4478 fb0eb 1644d8        	jsr	_OSSchedUnlock
4480                     ; 276              *perr = OS_ERR_NONE;
4482 fb0ee 69f30004      	clr	[OFST+4,s]
4483                     ; 278              return (OS_TRUE);
4486 fb0f2 c601          	ldab	#1
4489 fb0f4 31            	puly	
4490 fb0f5 3d            	rts	
4491 fb0f6               L7103:
4492                     ; 280         case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
4492                     ; 281              OSSchedUnlock();
4494 fb0f6 1644d8        	jsr	_OSSchedUnlock
4496                     ; 282              *perr = OS_ERR_TMR_INACTIVE;
4498 fb0f9 c687          	ldab	#135
4499 fb0fb 6bf30004      	stab	[OFST+4,s]
4500                     ; 284              return (OS_FALSE);
4503 fb0ff c7            	clrb	
4506 fb100 31            	puly	
4507 fb101 3d            	rts	
4564                     ; 400 _NEAR INT32U  OSTmrRemainGet (OS_TMR  *ptmr,
4564                     ; 401                              INT8U   *perr)
4564                     ; 402 {
4565                     	switch	.text
4566 fb102               _OSTmrRemainGet:
4568 fb102 3b            	pshd	
4569 fb103 1b9c          	leas	-4,s
4570       00000004      OFST:	set	4
4573                     ; 414     if (ptmr == (OS_TMR *)0) {
4575 fb105 046404        	tbne	d,L5213
4576                     ; 415         *perr = OS_ERR_TMR_INVALID;
4578 fb108 c68a          	ldab	#138
4579                     ; 416         return (0u);
4582 fb10a 200a          	bra	LC002
4583 fb10c               L5213:
4584                     ; 419     if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
4586 fb10c e6f30004      	ldab	[OFST+0,s]
4587 fb110 c164          	cmpb	#100
4588 fb112 270d          	beq	L7213
4589                     ; 420         *perr = OS_ERR_TMR_INVALID_TYPE;
4591 fb114 c689          	ldab	#137
4592                     ; 421         return (0u);
4594 fb116               LC002:
4595 fb116 6bf30008      	stab	[OFST+4,s]
4596 fb11a 87            	clra	
4597 fb11b c7            	clrb	
4598 fb11c b745          	tfr	d,x
4600 fb11e               L22:
4602 fb11e 1b86          	leas	6,s
4603 fb120 3d            	rts	
4604 fb121               L7213:
4605                     ; 423     if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
4607 fb121 f6163c        	ldab	_OSIntNesting
4608 fb124 2704          	beq	L1313
4609                     ; 424         *perr = OS_ERR_TMR_ISR;
4611 fb126 c68b          	ldab	#139
4612                     ; 425         return (0u);
4615 fb128 20ec          	bra	LC002
4616 fb12a               L1313:
4617                     ; 427     OSSchedLock();
4619 fb12a 1644b4        	jsr	_OSSchedLock
4621                     ; 428     switch (ptmr->OSTmrState) {
4623 fb12d ed84          	ldy	OFST+0,s
4624 fb12f e6e816        	ldab	22,y
4626 fb132 276b          	beq	L3703
4627 fb134 040128        	dbeq	b,L3603
4628 fb137 040157        	dbeq	b,L1703
4629 fb13a 040107        	dbeq	b,L1603
4630                     ; 466         default:
4630                     ; 467              OSSchedUnlock();
4632 fb13d 1644d8        	jsr	_OSSchedUnlock
4634                     ; 468              *perr = OS_ERR_TMR_INVALID_STATE;
4636 fb140 c68d          	ldab	#141
4637                     ; 469              return (0u);
4640 fb142 20d2          	bra	LC002
4641 fb144               L1603:
4642                     ; 429         case OS_TMR_STATE_RUNNING:
4642                     ; 430              remain = ptmr->OSTmrMatch - OSTmrTime;    /* Determine how much time is left to timeout                  */
4644 fb144 ec4b          	ldd	11,y
4645 fb146 ee49          	ldx	9,y
4646 fb148 cd13a5        	ldy	#_OSTmrTime
4647 fb14b 16c0fe        	jsr	c_lsub
4649 fb14e 6c82          	std	OFST-2,s
4650 fb150 6e80          	stx	OFST-4,s
4651                     ; 431              OSSchedUnlock();
4653 fb152 1644d8        	jsr	_OSSchedUnlock
4655                     ; 432              *perr  = OS_ERR_NONE;
4657 fb155 69f30008      	clr	[OFST+4,s]
4658                     ; 433              return (remain);
4660 fb159 ec82          	ldd	OFST-2,s
4661 fb15b ee80          	ldx	OFST-4,s
4663 fb15d 20bf          	bra	L22
4664 fb15f               L3603:
4665                     ; 435         case OS_TMR_STATE_STOPPED:                     /* It's assumed that the timer has not started yet             */
4665                     ; 436              switch (ptmr->OSTmrOpt) {
4667 fb15f e6e815        	ldab	21,y
4669 fb162 040117        	dbeq	b,L7603
4670 fb165 042114        	dbne	b,L7603
4671                     ; 437                  case OS_TMR_OPT_PERIODIC:
4671                     ; 438                       if (ptmr->OSTmrDly == 0u) {
4673 fb168 ec4d          	ldd	13,y
4674 fb16a 260e          	bne	L3413
4675 fb16c ec4f          	ldd	15,y
4676 fb16e 260a          	bne	L3413
4677                     ; 439                           remain = ptmr->OSTmrPeriod;
4679 fb170 ece813        	ldd	19,y
4680 fb173 6c82          	std	OFST-2,s
4681 fb175 ece811        	ldd	17,y
4683 fb178 2008          	bra	L1413
4684 fb17a               L3413:
4685                     ; 441                           remain = ptmr->OSTmrDly;
4687 fb17a ed84          	ldy	OFST+0,s
4688                     ; 443                       OSSchedUnlock();
4691                     ; 444                       *perr  = OS_ERR_NONE;
4693                     ; 445                       break;
4695 fb17c               L7603:
4696                     ; 447                  case OS_TMR_OPT_ONE_SHOT:
4696                     ; 448                  default:
4696                     ; 449                       remain = ptmr->OSTmrDly;
4698 fb17c 18024f82      	movw	15,y,OFST-2,s
4699 fb180 ec4d          	ldd	13,y
4700                     ; 450                       OSSchedUnlock();
4703                     ; 451                       *perr  = OS_ERR_NONE;
4705                     ; 452                       break;
4707 fb182               L1413:
4708 fb182 6c80          	std	OFST-4,s
4709 fb184 1644d8        	jsr	_OSSchedUnlock
4710 fb187 69f30008      	clr	[OFST+4,s]
4711                     ; 454              return (remain);
4713 fb18b ec82          	ldd	OFST-2,s
4714 fb18d ee80          	ldx	OFST-4,s
4716 fb18f 200b          	bra	L42
4717 fb191               L1703:
4718                     ; 456         case OS_TMR_STATE_COMPLETED:                   /* Only ONE-SHOT that timed out can be in this state           */
4718                     ; 457              OSSchedUnlock();
4720 fb191 1644d8        	jsr	_OSSchedUnlock
4722                     ; 458              *perr = OS_ERR_NONE;
4724 fb194 c7            	clrb	
4725 fb195 6bf30008      	stab	[OFST+4,s]
4726                     ; 459              return (0u);
4728 fb199 87            	clra	
4729 fb19a               LC003:
4730 fb19a b745          	tfr	d,x
4732 fb19c               L42:
4734 fb19c 1b86          	leas	6,s
4735 fb19e 3d            	rts	
4736 fb19f               L3703:
4737                     ; 461         case OS_TMR_STATE_UNUSED:
4737                     ; 462              OSSchedUnlock();
4739 fb19f 1644d8        	jsr	_OSSchedUnlock
4741                     ; 463              *perr = OS_ERR_TMR_INACTIVE;
4743 fb1a2 c687          	ldab	#135
4744 fb1a4 6bf30008      	stab	[OFST+4,s]
4745                     ; 464              return (0u);
4747 fb1a8 87            	clra	
4748 fb1a9 c7            	clrb	
4750 fb1aa 20ee          	bra	LC003
4806                     ; 501 _NEAR INT8U  OSTmrStateGet (OS_TMR  *ptmr,
4806                     ; 502                            INT8U   *perr)
4806                     ; 503 {
4807                     	switch	.text
4808 fb1ac               _OSTmrStateGet:
4810 fb1ac 3b            	pshd	
4811 fb1ad 37            	pshb	
4812       00000001      OFST:	set	1
4815                     ; 515     if (ptmr == (OS_TMR *)0) {
4817 fb1ae 046404        	tbne	d,L1023
4818                     ; 516         *perr = OS_ERR_TMR_INVALID;
4820 fb1b1 c68a          	ldab	#138
4821                     ; 517         return (0u);
4824 fb1b3 200a          	bra	LC005
4825 fb1b5               L1023:
4826                     ; 520     if (ptmr->OSTmrType != OS_TMR_TYPE) {              /* Validate timer structure                                    */
4828 fb1b5 e6f30001      	ldab	[OFST+0,s]
4829 fb1b9 c164          	cmpb	#100
4830 fb1bb 270a          	beq	L3023
4831                     ; 521         *perr = OS_ERR_TMR_INVALID_TYPE;
4833 fb1bd c689          	ldab	#137
4834                     ; 522         return (0u);
4836 fb1bf               LC005:
4837 fb1bf 6bf30005      	stab	[OFST+4,s]
4838 fb1c3 c7            	clrb	
4840 fb1c4               L03:
4842 fb1c4 1b83          	leas	3,s
4843 fb1c6 3d            	rts	
4844 fb1c7               L3023:
4845                     ; 524     if (OSIntNesting > 0u) {                           /* See if trying to call from an ISR                           */
4847 fb1c7 f6163c        	ldab	_OSIntNesting
4848 fb1ca 2704          	beq	L5023
4849                     ; 525         *perr = OS_ERR_TMR_ISR;
4851 fb1cc c68b          	ldab	#139
4852                     ; 526         return (0u);
4855 fb1ce 20ef          	bra	LC005
4856 fb1d0               L5023:
4857                     ; 528     OSSchedLock();
4859 fb1d0 1644b4        	jsr	_OSSchedLock
4861                     ; 529     state = ptmr->OSTmrState;
4863 fb1d3 ed81          	ldy	OFST+0,s
4864 fb1d5 e6e816        	ldab	22,y
4865 fb1d8 6b80          	stab	OFST-1,s
4866                     ; 530     switch (state) {
4869 fb1da 2711          	beq	L7413
4870 fb1dc 04010e        	dbeq	b,L7413
4871 fb1df 04010b        	dbeq	b,L7413
4872 fb1e2 040108        	dbeq	b,L7413
4873                     ; 538         default:
4873                     ; 539              *perr = OS_ERR_TMR_INVALID_STATE;
4875 fb1e5 c68d          	ldab	#141
4876 fb1e7 6bf30005      	stab	[OFST+4,s]
4877                     ; 540              break;
4879 fb1eb 2004          	bra	L1123
4880 fb1ed               L7413:
4881                     ; 531         case OS_TMR_STATE_UNUSED:
4881                     ; 532         case OS_TMR_STATE_STOPPED:
4881                     ; 533         case OS_TMR_STATE_COMPLETED:
4881                     ; 534         case OS_TMR_STATE_RUNNING:
4881                     ; 535              *perr = OS_ERR_NONE;
4883 fb1ed 69f30005      	clr	[OFST+4,s]
4884                     ; 536              break;
4886 fb1f1               L1123:
4887                     ; 542     OSSchedUnlock();
4889 fb1f1 1644d8        	jsr	_OSSchedUnlock
4891                     ; 543     return (state);
4893 fb1f4 e680          	ldab	OFST-1,s
4895 fb1f6 20cc          	bra	L03
4946                     ; 570 _NEAR BOOLEAN  OSTmrStart (OS_TMR   *ptmr,
4946                     ; 571                           INT8U    *perr)
4946                     ; 572 {
4947                     	switch	.text
4948 fb1f8               _OSTmrStart:
4950       00000000      OFST:	set	0
4953                     ; 581     if (ptmr == (OS_TMR *)0) {
4955 fb1f8 6cae          	std	2,-s
4956 fb1fa 2609          	bne	L7423
4957                     ; 582         *perr = OS_ERR_TMR_INVALID;
4959 fb1fc c68a          	ldab	#138
4960 fb1fe 6bf30004      	stab	[OFST+4,s]
4961                     ; 583         return (OS_FALSE);
4963 fb202 c7            	clrb	
4966 fb203 31            	puly	
4967 fb204 3d            	rts	
4968 fb205               L7423:
4969                     ; 589     if (ptmr->OSTmrType != OS_TMR_TYPE) {                   /* Validate timer structure                               */
4972 fb205 e6f30000      	ldab	[OFST+0,s]
4973 fb209 c164          	cmpb	#100
4974 fb20b 2709          	beq	L1523
4975                     ; 590         *perr = OS_ERR_TMR_INVALID_TYPE;
4977 fb20d c689          	ldab	#137
4978 fb20f 6bf30004      	stab	[OFST+4,s]
4979                     ; 592         return (OS_FALSE);
4982 fb213 c7            	clrb	
4985 fb214 31            	puly	
4986 fb215 3d            	rts	
4987 fb216               L1523:
4988                     ; 594     if (OSIntNesting > 0u) {                                /* See if trying to call from an ISR                      */
4990 fb216 f6163c        	ldab	_OSIntNesting
4991 fb219 2709          	beq	L3523
4992                     ; 595         *perr  = OS_ERR_TMR_ISR;
4994 fb21b c68b          	ldab	#139
4995 fb21d 6bf30004      	stab	[OFST+4,s]
4996                     ; 597         return (OS_FALSE);
4999 fb221 c7            	clrb	
5002 fb222 31            	puly	
5003 fb223 3d            	rts	
5004 fb224               L3523:
5005                     ; 599     OSSchedLock();
5007 fb224 1644b4        	jsr	_OSSchedLock
5009                     ; 600     switch (ptmr->OSTmrState) {
5011 fb227 ed80          	ldy	OFST+0,s
5012 fb229 e6e816        	ldab	22,y
5014 fb22c 2744          	beq	L7123
5015 fb22e 04012c        	dbeq	b,L5123
5016 fb231 040129        	dbeq	b,L5123
5017 fb234 04010c        	dbeq	b,L3123
5018                     ; 623         default:
5018                     ; 624              OSSchedUnlock();
5020 fb237 1644d8        	jsr	_OSSchedUnlock
5022                     ; 625              *perr = OS_ERR_TMR_INVALID_STATE;
5024 fb23a c68d          	ldab	#141
5025 fb23c 6bf30004      	stab	[OFST+4,s]
5026                     ; 627              return (OS_FALSE);
5029 fb240 c7            	clrb	
5032 fb241 31            	puly	
5033 fb242 3d            	rts	
5034 fb243               L3123:
5035                     ; 601         case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
5035                     ; 602              OSTmr_Unlink(ptmr);                            /* ... Stop the timer                                     */
5037 fb243 b764          	tfr	y,d
5038 fb245 1674ce        	jsr	L3562_OSTmr_Unlink
5040                     ; 603              OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
5042 fb248 87            	clra	
5043 fb249 c7            	clrb	
5044 fb24a 3b            	pshd	
5045 fb24b ec82          	ldd	OFST+2,s
5046 fb24d 167466        	jsr	L1562_OSTmr_Link
5048 fb250 1b82          	leas	2,s
5049                     ; 604              OSSchedUnlock();
5051 fb252 1644d8        	jsr	_OSSchedUnlock
5053                     ; 605              *perr = OS_ERR_NONE;
5055 fb255 69f30004      	clr	[OFST+4,s]
5056                     ; 607              return (OS_TRUE);
5059 fb259 c601          	ldab	#1
5062 fb25b 31            	puly	
5063 fb25c 3d            	rts	
5064 fb25d               L5123:
5065                     ; 609         case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
5065                     ; 610         case OS_TMR_STATE_COMPLETED:
5065                     ; 611              OSTmr_Link(ptmr, OS_TMR_LINK_DLY);             /* ... Link timer to timer wheel                          */
5067 fb25d 87            	clra	
5068 fb25e c7            	clrb	
5069 fb25f 3b            	pshd	
5070 fb260 b764          	tfr	y,d
5071 fb262 167466        	jsr	L1562_OSTmr_Link
5073 fb265 1b82          	leas	2,s
5074                     ; 612              OSSchedUnlock();
5076 fb267 1644d8        	jsr	_OSSchedUnlock
5078                     ; 613              *perr = OS_ERR_NONE;
5080 fb26a 69f30004      	clr	[OFST+4,s]
5081                     ; 615              return (OS_TRUE);
5084 fb26e c601          	ldab	#1
5087 fb270 31            	puly	
5088 fb271 3d            	rts	
5089 fb272               L7123:
5090                     ; 617         case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
5090                     ; 618              OSSchedUnlock();
5092 fb272 1644d8        	jsr	_OSSchedUnlock
5094                     ; 619              *perr = OS_ERR_TMR_INACTIVE;
5096 fb275 c687          	ldab	#135
5097 fb277 6bf30004      	stab	[OFST+4,s]
5098                     ; 621              return (OS_FALSE);
5101 fb27b c7            	clrb	
5104 fb27c 31            	puly	
5105 fb27d 3d            	rts	
5183                     ; 671 _NEAR BOOLEAN  OSTmrStop (OS_TMR  *ptmr,
5183                     ; 672                          INT8U    opt,
5183                     ; 673                          void    *callback_arg,
5183                     ; 674                          INT8U   *perr)
5183                     ; 675 {
5184                     	switch	.text
5185 fb27e               _OSTmrStop:
5187 fb27e 3b            	pshd	
5188       00000002      OFST:	set	2
5191                     ; 687     if (ptmr == (OS_TMR *)0) {
5193 fb27f 6cae          	std	2,-s
5194 fb281 2604          	bne	L7333
5195                     ; 688         *perr = OS_ERR_TMR_INVALID;
5197 fb283 c68a          	ldab	#138
5198                     ; 689         return (OS_FALSE);
5201 fb285 200a          	bra	L63
5202 fb287               L7333:
5203                     ; 695     if (ptmr->OSTmrType != OS_TMR_TYPE) {                         /* Validate timer structure                         */
5206 fb287 e6f30002      	ldab	[OFST+0,s]
5207 fb28b c164          	cmpb	#100
5208 fb28d 270a          	beq	L1433
5209                     ; 696         *perr = OS_ERR_TMR_INVALID_TYPE;
5211 fb28f c689          	ldab	#137
5212                     ; 698         return (OS_FALSE);
5216 fb291               L63:
5217 fb291 6bf3000a      	stab	[OFST+8,s]
5218 fb295 c7            	clrb	
5220 fb296 1b84          	leas	4,s
5221 fb298 3d            	rts	
5222 fb299               L1433:
5223                     ; 700     if (OSIntNesting > 0u) {                                      /* See if trying to call from an ISR                */
5225 fb299 f6163c        	ldab	_OSIntNesting
5226 fb29c 2704          	beq	L3433
5227                     ; 701         *perr  = OS_ERR_TMR_ISR;
5229 fb29e c68b          	ldab	#139
5230                     ; 703         return (OS_FALSE);
5234 fb2a0 20ef          	bra	L63
5235 fb2a2               L3433:
5236                     ; 705     OSSchedLock();
5238 fb2a2 1644b4        	jsr	_OSSchedLock
5240                     ; 706     switch (ptmr->OSTmrState) {
5242 fb2a5 ed82          	ldy	OFST+0,s
5243 fb2a7 e6e816        	ldab	22,y
5245 fb2aa 2764          	beq	L5723
5246 fb2ac 040153        	dbeq	b,L3723
5247 fb2af 040150        	dbeq	b,L3723
5248 fb2b2 040107        	dbeq	b,L1623
5249                     ; 753         default:
5249                     ; 754              OSSchedUnlock();
5251 fb2b5 1644d8        	jsr	_OSSchedUnlock
5253                     ; 755              *perr = OS_ERR_TMR_INVALID_STATE;
5255 fb2b8 c68d          	ldab	#141
5256                     ; 757              return (OS_FALSE);
5260 fb2ba 20d5          	bra	L63
5261 fb2bc               L1623:
5262                     ; 707         case OS_TMR_STATE_RUNNING:
5262                     ; 708              OSTmr_Unlink(ptmr);                                  /* Remove from current wheel spoke                  */
5264 fb2bc b764          	tfr	y,d
5265 fb2be 1674ce        	jsr	L3562_OSTmr_Unlink
5267                     ; 709              *perr = OS_ERR_NONE;
5269 fb2c1 ed8a          	ldy	OFST+8,s
5270 fb2c3 6940          	clr	0,y
5271                     ; 710              switch (opt) {
5273 fb2c5 e687          	ldab	OFST+5,s
5275 fb2c7 2734          	beq	L3533
5276 fb2c9 c003          	subb	#3
5277 fb2cb 2709          	beq	L3623
5278 fb2cd 040112        	dbeq	b,L5623
5279                     ; 732                  default:
5279                     ; 733                      *perr = OS_ERR_TMR_INVALID_OPT;
5281 fb2d0 c684          	ldab	#132
5282 fb2d2 6b40          	stab	0,y
5283                     ; 734                      break;
5285 fb2d4 2027          	bra	L3533
5286 fb2d6               L3623:
5287                     ; 711                  case OS_TMR_OPT_CALLBACK:
5287                     ; 712                       pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
5289 fb2d6 ed82          	ldy	OFST+0,s
5290 fb2d8 ec41          	ldd	1,y
5291 fb2da 6c80          	std	OFST-2,s
5292                     ; 713                       if (pfnct != (OS_TMR_CALLBACK)0) {
5294 fb2dc 2719          	beq	L1633
5295                     ; 714                           (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);  /* Use callback arg when timer was created */
5297 fb2de ec43          	ldd	3,y
5300 fb2e0 200a          	bra	LC007
5301                     ; 716                           *perr = OS_ERR_TMR_NO_CALLBACK;
5303 fb2e2               L5623:
5304                     ; 720                  case OS_TMR_OPT_CALLBACK_ARG:
5304                     ; 721                       pfnct = ptmr->OSTmrCallback;                /* Execute callback function if available ...       */
5306 fb2e2 ed82          	ldy	OFST+0,s
5307 fb2e4 ec41          	ldd	1,y
5308 fb2e6 6c80          	std	OFST-2,s
5309                     ; 722                       if (pfnct != (OS_TMR_CALLBACK)0) {
5311 fb2e8 270d          	beq	L1633
5312                     ; 723                           (*pfnct)((void *)ptmr, callback_arg);   /* ... using the 'callback_arg' provided in call    */
5314 fb2ea ec88          	ldd	OFST+6,s
5316 fb2ec               LC007:
5317 fb2ec 3b            	pshd	
5318 fb2ed ec84          	ldd	OFST+2,s
5319 fb2ef 15f30002      	jsr	[OFST+0,s]
5320 fb2f3 1b82          	leas	2,s
5322 fb2f5 2006          	bra	L3533
5323 fb2f7               L1633:
5324                     ; 725                           *perr = OS_ERR_TMR_NO_CALLBACK;
5326 fb2f7 c68f          	ldab	#143
5327 fb2f9 6bf3000a      	stab	[OFST+8,s]
5328 fb2fd               L3533:
5329                     ; 736              OSSchedUnlock();
5331 fb2fd 1644d8        	jsr	_OSSchedUnlock
5333                     ; 738              return (OS_TRUE);
5337 fb300 2009          	bra	LC008
5338 fb302               L3723:
5339                     ; 740         case OS_TMR_STATE_COMPLETED:                              /* Timer has already completed the ONE-SHOT or ...  */
5339                     ; 741         case OS_TMR_STATE_STOPPED:                                /* ... timer has not started yet.                   */
5339                     ; 742              OSSchedUnlock();
5341 fb302 1644d8        	jsr	_OSSchedUnlock
5343                     ; 743              *perr = OS_ERR_TMR_STOPPED;
5345 fb305 c68e          	ldab	#142
5346 fb307 6bf3000a      	stab	[OFST+8,s]
5347                     ; 745              return (OS_TRUE);
5350 fb30b               LC008:
5351 fb30b c601          	ldab	#1
5353 fb30d               L04:
5355 fb30d 1b84          	leas	4,s
5356 fb30f 3d            	rts	
5357 fb310               L5723:
5358                     ; 747         case OS_TMR_STATE_UNUSED:                                 /* Timer was not created                            */
5358                     ; 748              OSSchedUnlock();
5360 fb310 1644d8        	jsr	_OSSchedUnlock
5362                     ; 749              *perr = OS_ERR_TMR_INACTIVE;
5364 fb313 c687          	ldab	#135
5365 fb315 6bf3000a      	stab	[OFST+8,s]
5366                     ; 751              return (OS_FALSE);
5369 fb319 c7            	clrb	
5371 fb31a 20f1          	bra	L04
5404                     ; 783 _NEAR INT8U  OSTmrSignal (void)
5404                     ; 784 {
5405                     	switch	.text
5406 fb31c               _OSTmrSignal:
5408 fb31c 37            	pshb	
5409       00000001      OFST:	set	1
5412                     ; 788     err = OSSemPost(OSTmrSemSignal);
5414 fb31d fc13a1        	ldd	_OSTmrSemSignal
5415 fb320 1666b9        	jsr	_OSSemPost
5417                     ; 789     return (err);
5421 fb323 1b81          	leas	1,s
5422 fb325 3d            	rts	
5464                     ; 807 static  OS_TMR  *OSTmr_Alloc (void)
5464                     ; 808 {
5465                     	switch	.text
5466 fb326               L3462_OSTmr_Alloc:
5468 fb326 3b            	pshd	
5469       00000002      OFST:	set	2
5472                     ; 812     if (OSTmrFreeList == (OS_TMR *)0) {
5474 fb327 fd122f        	ldy	_OSTmrFreeList
5475 fb32a 2604          	bne	L3243
5476                     ; 813         return ((OS_TMR *)0);
5478 fb32c 87            	clra	
5479 fb32d c7            	clrb	
5482 fb32e 31            	puly	
5483 fb32f 3d            	rts	
5484 fb330               L3243:
5485                     ; 815     ptmr            = (OS_TMR *)OSTmrFreeList;
5487 fb330 6d80          	sty	OFST-2,s
5488                     ; 816     OSTmrFreeList   = (OS_TMR *)ptmr->OSTmrNext;
5490 fb332 180545122f    	movw	5,y,_OSTmrFreeList
5491                     ; 817     ptmr->OSTmrNext = (OS_TCB *)0;
5493 fb337 87            	clra	
5494 fb338 c7            	clrb	
5495 fb339 6c45          	std	5,y
5496                     ; 818     ptmr->OSTmrPrev = (OS_TCB *)0;
5498 fb33b 6c47          	std	7,y
5499                     ; 819     OSTmrUsed++;
5501 fb33d fd13a9        	ldy	_OSTmrUsed
5502 fb340 02            	iny	
5503 fb341 7d13a9        	sty	_OSTmrUsed
5504                     ; 820     OSTmrFree--;
5506 fb344 fd13ab        	ldy	_OSTmrFree
5507 fb347 03            	dey	
5508 fb348 7d13ab        	sty	_OSTmrFree
5509                     ; 821     return (ptmr);
5511 fb34b ec80          	ldd	OFST-2,s
5514 fb34d 31            	puly	
5515 fb34e 3d            	rts	
5554                     ; 839 static  void  OSTmr_Free (OS_TMR *ptmr)
5554                     ; 840 {
5555                     	switch	.text
5556 fb34f               L5462_OSTmr_Free:
5558 fb34f 3b            	pshd	
5559       00000000      OFST:	set	0
5562                     ; 841     ptmr->OSTmrState       = OS_TMR_STATE_UNUSED;      /* Clear timer object fields                                   */
5564 fb350 b746          	tfr	d,y
5565                     ; 842     ptmr->OSTmrOpt         = OS_TMR_OPT_NONE;
5567 fb352 87            	clra	
5568 fb353 c7            	clrb	
5569 fb354 6ce815        	std	21,y
5570                     ; 843     ptmr->OSTmrPeriod      = 0u;
5572 fb357 6ce813        	std	19,y
5573 fb35a 6ce811        	std	17,y
5574                     ; 844     ptmr->OSTmrMatch       = 0u;
5576 fb35d ed80          	ldy	OFST+0,s
5577 fb35f 6c4b          	std	11,y
5578 fb361 6c49          	std	9,y
5579                     ; 845     ptmr->OSTmrCallback    = (OS_TMR_CALLBACK)0;
5581 fb363 6c41          	std	1,y
5582                     ; 846     ptmr->OSTmrCallbackArg = (void *)0;
5584 fb365 6c43          	std	3,y
5585                     ; 851     ptmr->OSTmrPrev        = (OS_TCB *)0;              /* Chain timer to free list                                    */
5587 fb367 6c47          	std	7,y
5588                     ; 852     ptmr->OSTmrNext        = OSTmrFreeList;
5590 fb369 180145122f    	movw	_OSTmrFreeList,5,y
5591                     ; 853     OSTmrFreeList          = ptmr;
5593 fb36e 7d122f        	sty	_OSTmrFreeList
5594                     ; 855     OSTmrUsed--;                                       /* Update timer object statistics                              */
5596 fb371 fd13a9        	ldy	_OSTmrUsed
5597 fb374 03            	dey	
5598 fb375 7d13a9        	sty	_OSTmrUsed
5599                     ; 856     OSTmrFree++;
5601 fb378 fd13ab        	ldy	_OSTmrFree
5602 fb37b 02            	iny	
5603 fb37c 7d13ab        	sty	_OSTmrFree
5604                     ; 857 }
5607 fb37f 31            	puly	
5608 fb380 3d            	rts	
5689                     ; 875 _NEAR void  OSTmr_Init (void)
5689                     ; 876 {
5690                     	switch	.text
5691 fb381               _OSTmr_Init:
5693 fb381 1b99          	leas	-7,s
5694       00000007      OFST:	set	7
5697                     ; 886     OS_MemClr((INT8U *)&OSTmrTbl[0],      sizeof(OSTmrTbl));            /* Clear all the TMRs                         */
5699 fb383 cc0170        	ldd	#368
5700 fb386 3b            	pshd	
5701 fb387 cc1231        	ldd	#_OSTmrTbl
5702 fb38a 164907        	jsr	_OS_MemClr
5704                     ; 887     OS_MemClr((INT8U *)&OSTmrWheelTbl[0], sizeof(OSTmrWheelTbl));       /* Clear the timer wheel                      */
5706 fb38d cc0020        	ldd	#32
5707 fb390 6c80          	std	0,s
5708 fb392 cc116f        	ldd	#_OSTmrWheelTbl
5709 fb395 164907        	jsr	_OS_MemClr
5711 fb398 1b82          	leas	2,s
5712                     ; 889     for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
5714 fb39a 87            	clra	
5715 fb39b c7            	clrb	
5716 fb39c b746          	tfr	d,y
5717 fb39e 6d82          	sty	OFST-5,s
5718 fb3a0               L1053:
5719                     ; 890         ix_next = ix + 1u;
5721 fb3a0 02            	iny	
5722 fb3a1 6d84          	sty	OFST-3,s
5723                     ; 891         ptmr1 = &OSTmrTbl[ix];
5725 fb3a3 cd0017        	ldy	#23
5726 fb3a6 13            	emul	
5727 fb3a7 c31231        	addd	#_OSTmrTbl
5728 fb3aa 6c80          	std	OFST-7,s
5729                     ; 892         ptmr2 = &OSTmrTbl[ix_next];
5731 fb3ac ec84          	ldd	OFST-3,s
5732 fb3ae cd0017        	ldy	#23
5733 fb3b1 13            	emul	
5734 fb3b2 c31231        	addd	#_OSTmrTbl
5735 fb3b5 6c84          	std	OFST-3,s
5736                     ; 893         ptmr1->OSTmrType    = OS_TMR_TYPE;
5738 fb3b7 c664          	ldab	#100
5739 fb3b9 ed80          	ldy	OFST-7,s
5740 fb3bb 6b40          	stab	0,y
5741                     ; 894         ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                      /* Indicate that timer is inactive            */
5743 fb3bd 69e816        	clr	22,y
5744                     ; 895         ptmr1->OSTmrNext    = (void *)ptmr2;                            /* Link to next timer                         */
5746 fb3c0 18028445      	movw	OFST-3,s,5,y
5747                     ; 889     for (ix = 0u; ix < (OS_TMR_CFG_MAX - 1u); ix++) {                   /* Init. list of free TMRs                    */
5749 fb3c4 ed82          	ldy	OFST-5,s
5750 fb3c6 02            	iny	
5753 fb3c7 b764          	tfr	y,d
5754 fb3c9 6c82          	std	OFST-5,s
5755 fb3cb 8c000f        	cpd	#15
5756 fb3ce 25d0          	blo	L1053
5757                     ; 900     ptmr1               = &OSTmrTbl[ix];
5759 fb3d0 cd0017        	ldy	#23
5760 fb3d3 13            	emul	
5761 fb3d4 c31231        	addd	#_OSTmrTbl
5762 fb3d7 6c80          	std	OFST-7,s
5763                     ; 901     ptmr1->OSTmrType    = OS_TMR_TYPE;
5765 fb3d9 c664          	ldab	#100
5766 fb3db ed80          	ldy	OFST-7,s
5767 fb3dd 6b40          	stab	0,y
5768                     ; 902     ptmr1->OSTmrState   = OS_TMR_STATE_UNUSED;                          /* Indicate that timer is inactive            */
5770 fb3df 87            	clra	
5771 fb3e0 6ae816        	staa	22,y
5772                     ; 903     ptmr1->OSTmrNext    = (void *)0;                                    /* Last OS_TMR                                */
5774 fb3e3 c7            	clrb	
5775 fb3e4 6c45          	std	5,y
5776                     ; 907     OSTmrTime           = 0u;
5778 fb3e6 7c13a7        	std	_OSTmrTime+2
5779 fb3e9 7c13a5        	std	_OSTmrTime
5780                     ; 908     OSTmrUsed           = 0u;
5782 fb3ec 7c13a9        	std	_OSTmrUsed
5783                     ; 909     OSTmrFree           = OS_TMR_CFG_MAX;
5785 fb3ef c610          	ldab	#16
5786 fb3f1 7c13ab        	std	_OSTmrFree
5787                     ; 910     OSTmrFreeList       = &OSTmrTbl[0];
5789 fb3f4 cc1231        	ldd	#_OSTmrTbl
5790 fb3f7 7c122f        	std	_OSTmrFreeList
5791                     ; 911     OSTmrSem            = OSSemCreate(1u);
5793 fb3fa cc0001        	ldd	#1
5794 fb3fd 16648d        	jsr	_OSSemCreate
5796 fb400 7c13a3        	std	_OSTmrSem
5797                     ; 912     OSTmrSemSignal      = OSSemCreate(0u);
5799 fb403 87            	clra	
5800 fb404 c7            	clrb	
5801 fb405 16648d        	jsr	_OSSemCreate
5803 fb408 7c13a1        	std	_OSTmrSemSignal
5804                     ; 915     OSEventNameSet(OSTmrSem,       (INT8U *)(void *)"uC/OS-II TmrLock",   &err);
5806 fb40b 1a86          	leax	OFST-1,s
5807 fb40d 34            	pshx	
5808 fb40e cc7765        	ldd	#L7053
5809 fb411 3b            	pshd	
5810 fb412 fc13a3        	ldd	_OSTmrSem
5811 fb415 16417b        	jsr	_OSEventNameSet
5813 fb418 1b84          	leas	4,s
5814                     ; 916     OSEventNameSet(OSTmrSemSignal, (INT8U *)(void *)"uC/OS-II TmrSignal", &err);
5816 fb41a 1a86          	leax	OFST-1,s
5817 fb41c 34            	pshx	
5818 fb41d cc7752        	ldd	#L1153
5819 fb420 3b            	pshd	
5820 fb421 fc13a1        	ldd	_OSTmrSemSignal
5821 fb424 16417b        	jsr	_OSEventNameSet
5823 fb427 1b84          	leas	4,s
5824                     ; 919     OSTmr_InitTask();
5826 fb429 0703          	jsr	L7462_OSTmr_InitTask
5828                     ; 920 }
5831 fb42b 1b87          	leas	7,s
5832 fb42d 3d            	rts	
5868                     ; 936 static  void  OSTmr_InitTask (void)
5868                     ; 937 {
5869                     	switch	.text
5870 fb42e               L7462_OSTmr_InitTask:
5872 fb42e 37            	pshb	
5873       00000001      OFST:	set	1
5876                     ; 945     (void)OSTaskCreateExt(OSTmr_Task,
5876                     ; 946                           (void *)0,                                       /* No arguments passed to OSTmrTask()      */
5876                     ; 947                           &OSTmrTaskStk[OS_TASK_TMR_STK_SIZE - 1u],        /* Set Top-Of-Stack                        */
5876                     ; 948                           OS_TASK_TMR_PRIO,
5876                     ; 949                           OS_TASK_TMR_ID,
5876                     ; 950                           &OSTmrTaskStk[0],                                /* Set Bottom-Of-Stack                     */
5876                     ; 951                           OS_TASK_TMR_STK_SIZE,
5876                     ; 952                           (void *)0,                                       /* No TCB extension                        */
5876                     ; 953                           OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);      /* Enable stack checking + clear stack     */
5878 fb42f cc0003        	ldd	#3
5879 fb432 3b            	pshd	
5880 fb433 c7            	clrb	
5881 fb434 3b            	pshd	
5882 fb435 c6a0          	ldab	#160
5883 fb437 3b            	pshd	
5884 fb438 c7            	clrb	
5885 fb439 3b            	pshd	
5886 fb43a cc118f        	ldd	#_OSTmrTaskStk
5887 fb43d 3b            	pshd	
5888 fb43e ccfffd        	ldd	#-3
5889 fb441 3b            	pshd	
5890 fb442 cc003d        	ldd	#61
5891 fb445 3b            	pshd	
5892 fb446 cc122e        	ldd	#_OSTmrTaskStk+159
5893 fb449 3b            	pshd	
5894 fb44a 87            	clra	
5895 fb44b c7            	clrb	
5896 fb44c 3b            	pshd	
5897 fb44d cc7524        	ldd	#L5562_OSTmr_Task
5898 fb450 1669d1        	jsr	_OSTaskCreateExt
5900 fb453 1bf012        	leas	18,s
5901                     ; 980     OSTaskNameSet(OS_TASK_TMR_PRIO, (INT8U *)(void *)"uC/OS-II Tmr", &err);
5903 fb456 1a80          	leax	OFST-1,s
5904 fb458 34            	pshx	
5905 fb459 cc7745        	ldd	#L7253
5906 fb45c 3b            	pshd	
5907 fb45d cc003d        	ldd	#61
5908 fb460 166c91        	jsr	_OSTaskNameSet
5910                     ; 982 }
5913 fb463 1b85          	leas	5,s
5914 fb465 3d            	rts	
6016                     ; 1004 static  void  OSTmr_Link (OS_TMR  *ptmr,
6016                     ; 1005                           INT8U    type)
6016                     ; 1006 {
6017                     	switch	.text
6018 fb466               L1562_OSTmr_Link:
6020 fb466 3b            	pshd	
6021 fb467 1b9c          	leas	-4,s
6022       00000004      OFST:	set	4
6025                     ; 1012     ptmr->OSTmrState = OS_TMR_STATE_RUNNING;
6027 fb469 c603          	ldab	#3
6028 fb46b ed84          	ldy	OFST+0,s
6029 fb46d 6be816        	stab	22,y
6030                     ; 1013     if (type == OS_TMR_LINK_PERIODIC) {                            /* Determine when timer will expire                */
6032 fb470 e689          	ldab	OFST+5,s
6033 fb472 53            	decb	
6034                     ; 1014         ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
6038 fb473 2708          	beq	LC009
6039                     ; 1016         if (ptmr->OSTmrDly == 0u) {
6041 fb475 ec4d          	ldd	13,y
6042 fb477 260c          	bne	L1163
6043 fb479 ec4f          	ldd	15,y
6044 fb47b 2608          	bne	L1163
6045                     ; 1017             ptmr->OSTmrMatch = ptmr->OSTmrPeriod + OSTmrTime;
6047 fb47d               LC009:
6048 fb47d ece813        	ldd	19,y
6049 fb480 eee811        	ldx	17,y
6052 fb483 2004          	bra	L7063
6053 fb485               L1163:
6054                     ; 1019             ptmr->OSTmrMatch = ptmr->OSTmrDly    + OSTmrTime;
6056 fb485 ec4f          	ldd	15,y
6057 fb487 ee4d          	ldx	13,y
6059 fb489               L7063:
6060 fb489 cd13a5        	ldy	#_OSTmrTime
6061 fb48c 16c0f3        	jsr	c_ladd
6062 fb48f ed84          	ldy	OFST+0,s
6063 fb491 6c4b          	std	11,y
6064 fb493 6e49          	stx	9,y
6065                     ; 1022     spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
6067 fb495 c407          	andb	#7
6068 fb497 87            	clra	
6069 fb498 6c82          	std	OFST-2,s
6070                     ; 1023     pspoke = &OSTmrWheelTbl[spoke];
6072 fb49a 59            	lsld	
6073 fb49b 59            	lsld	
6074 fb49c c3116f        	addd	#_OSTmrWheelTbl
6075                     ; 1025     if (pspoke->OSTmrFirst == (OS_TMR *)0) {                       /* Link into timer wheel                           */
6077 fb49f b745          	tfr	d,x
6078 fb4a1 6e80          	stx	OFST-4,s
6079 fb4a3 ec00          	ldd	0,x
6080 fb4a5 2609          	bne	L5163
6081                     ; 1026         pspoke->OSTmrFirst   = ptmr;
6083 fb4a7 6d00          	sty	0,x
6084                     ; 1027         ptmr->OSTmrNext      = (OS_TMR *)0;
6086 fb4a9 6c45          	std	5,y
6087                     ; 1028         pspoke->OSTmrEntries = 1u;
6089 fb4ab 52            	incb	
6090 fb4ac b756          	tfr	x,y
6092 fb4ae 2013          	bra	L7163
6093 fb4b0               L5163:
6094                     ; 1030         ptmr1                = pspoke->OSTmrFirst;                 /* Point to first timer in the spoke               */
6096 fb4b0 6c82          	std	OFST-2,s
6097                     ; 1031         pspoke->OSTmrFirst   = ptmr;
6099 fb4b2 6d00          	sty	0,x
6100                     ; 1032         ptmr->OSTmrNext      = (void *)ptmr1;
6102 fb4b4 6c45          	std	5,y
6103                     ; 1033         ptmr1->OSTmrPrev     = (void *)ptmr;
6105 fb4b6 b764          	tfr	y,d
6106 fb4b8 ed82          	ldy	OFST-2,s
6107 fb4ba 6c47          	std	7,y
6108                     ; 1034         pspoke->OSTmrEntries++;
6110 fb4bc b756          	tfr	x,y
6111 fb4be ec42          	ldd	2,y
6112 fb4c0 c30001        	addd	#1
6113 fb4c3               L7163:
6114 fb4c3 6c42          	std	2,y
6115                     ; 1036     ptmr->OSTmrPrev = (void *)0;                                   /* Timer always inserted as first node in list     */
6117 fb4c5 87            	clra	
6118 fb4c6 c7            	clrb	
6119 fb4c7 ee84          	ldx	OFST+0,s
6120 fb4c9 6c07          	std	7,x
6121                     ; 1037 }
6124 fb4cb 1b86          	leas	6,s
6125 fb4cd 3d            	rts	
6205                     ; 1054 static  void  OSTmr_Unlink (OS_TMR *ptmr)
6205                     ; 1055 {
6206                     	switch	.text
6207 fb4ce               L3562_OSTmr_Unlink:
6209 fb4ce 3b            	pshd	
6210 fb4cf 1b9a          	leas	-6,s
6211       00000006      OFST:	set	6
6214                     ; 1062     spoke  = (INT16U)(ptmr->OSTmrMatch % OS_TMR_CFG_WHEEL_SIZE);
6216 fb4d1 b746          	tfr	d,y
6217 fb4d3 e64c          	ldab	12,y
6218 fb4d5 c407          	andb	#7
6219 fb4d7 87            	clra	
6220 fb4d8 6c82          	std	OFST-4,s
6221                     ; 1063     pspoke = &OSTmrWheelTbl[spoke];
6223 fb4da 59            	lsld	
6224 fb4db 59            	lsld	
6225 fb4dc c3116f        	addd	#_OSTmrWheelTbl
6226                     ; 1065     if (pspoke->OSTmrFirst == ptmr) {                       /* See if timer to remove is at the beginning of list     */
6228 fb4df b745          	tfr	d,x
6229 fb4e1 6e84          	stx	OFST-2,s
6230 fb4e3 ec00          	ldd	0,x
6231 fb4e5 ac86          	cpd	OFST+0,s
6232 fb4e7 260e          	bne	L5663
6233                     ; 1066         ptmr1              = (OS_TMR *)ptmr->OSTmrNext;
6235 fb4e9 ed86          	ldy	OFST+0,s
6236 fb4eb ed45          	ldy	5,y
6237 fb4ed 6d80          	sty	OFST-6,s
6238                     ; 1067         pspoke->OSTmrFirst = (OS_TMR *)ptmr1;
6240 fb4ef 6d00          	sty	0,x
6241                     ; 1068         if (ptmr1 != (OS_TMR *)0) {
6243 fb4f1 271a          	beq	L1763
6244                     ; 1069             ptmr1->OSTmrPrev = (void *)0;
6246 fb4f3 87            	clra	
6247 fb4f4 c7            	clrb	
6248 fb4f5 2014          	bra	LC010
6249 fb4f7               L5663:
6250                     ; 1072         ptmr1            = (OS_TMR *)ptmr->OSTmrPrev;       /* Remove timer from somewhere in the list                */
6252 fb4f7 ed86          	ldy	OFST+0,s
6253 fb4f9 18024780      	movw	7,y,OFST-6,s
6254                     ; 1073         ptmr2            = (OS_TMR *)ptmr->OSTmrNext;
6256 fb4fd ec45          	ldd	5,y
6257 fb4ff 6c82          	std	OFST-4,s
6258                     ; 1074         ptmr1->OSTmrNext = ptmr2;
6260 fb501 ed80          	ldy	OFST-6,s
6261 fb503 6c45          	std	5,y
6262                     ; 1075         if (ptmr2 != (OS_TMR *)0) {
6264 fb505 2706          	beq	L1763
6265                     ; 1076             ptmr2->OSTmrPrev = (void *)ptmr1;
6267 fb507 b764          	tfr	y,d
6268 fb509 ed82          	ldy	OFST-4,s
6269 fb50b               LC010:
6270 fb50b 6c47          	std	7,y
6271 fb50d               L1763:
6272                     ; 1079     ptmr->OSTmrState = OS_TMR_STATE_STOPPED;
6274 fb50d c601          	ldab	#1
6275 fb50f ed86          	ldy	OFST+0,s
6276 fb511 6be816        	stab	22,y
6277                     ; 1080     ptmr->OSTmrNext  = (void *)0;
6279 fb514 87            	clra	
6280 fb515 c7            	clrb	
6281 fb516 6c45          	std	5,y
6282                     ; 1081     ptmr->OSTmrPrev  = (void *)0;
6284 fb518 6c47          	std	7,y
6285                     ; 1082     pspoke->OSTmrEntries--;
6287 fb51a b756          	tfr	x,y
6288 fb51c ee42          	ldx	2,y
6289 fb51e 09            	dex	
6290 fb51f 6e42          	stx	2,y
6291                     ; 1083 }
6294 fb521 1b88          	leas	8,s
6295 fb523 3d            	rts	
6398                     ; 1100 static  void  OSTmr_Task (void *p_arg)
6398                     ; 1101 {
6399                     	switch	.text
6400 fb524               L5562_OSTmr_Task:
6402 fb524 3b            	pshd	
6403 fb525 1b99          	leas	-7,s
6404       00000007      OFST:	set	7
6407                     ; 1110     p_arg = p_arg;                                               /* Prevent compiler warning for not using 'p_arg'    */
6409 fb527               L5473:
6410                     ; 1112         OSSemPend(OSTmrSemSignal, 0u, &err);                     /* Wait for signal indicating time to update timers  */
6412 fb527 1a86          	leax	OFST-1,s
6413 fb529 34            	pshx	
6414 fb52a 87            	clra	
6415 fb52b c7            	clrb	
6416 fb52c 3b            	pshd	
6417 fb52d 3b            	pshd	
6418 fb52e fc13a1        	ldd	_OSTmrSemSignal
6419 fb531 16658f        	jsr	_OSSemPend
6421 fb534 1b86          	leas	6,s
6422                     ; 1113         OSSchedLock();
6424 fb536 1644b4        	jsr	_OSSchedLock
6426                     ; 1114         OSTmrTime++;                                             /* Increment the current time                        */
6428 fb539 fc13a7        	ldd	_OSTmrTime+2
6429 fb53c c30001        	addd	#1
6430 fb53f 7c13a7        	std	_OSTmrTime+2
6431 fb542 2408          	bcc	L46
6432 fb544 7213a6        	inc	_OSTmrTime+1
6433 fb547 2603          	bne	L46
6434 fb549 7213a5        	inc	_OSTmrTime
6435 fb54c               L46:
6436                     ; 1115         spoke  = (INT16U)(OSTmrTime % OS_TMR_CFG_WHEEL_SIZE);    /* Position on current timer wheel entry             */
6438 fb54c c407          	andb	#7
6439 fb54e 87            	clra	
6440                     ; 1116         pspoke = &OSTmrWheelTbl[spoke];
6442 fb54f 59            	lsld	
6443 fb550 59            	lsld	
6444 fb551 c3116f        	addd	#_OSTmrWheelTbl
6445 fb554 6c82          	std	OFST-5,s
6446                     ; 1117         ptmr   = pspoke->OSTmrFirst;
6448 fb556 ecf30002      	ldd	[OFST-5,s]
6450 fb55a 2049          	bra	L5573
6451 fb55c               L1573:
6452                     ; 1119             ptmr_next = (OS_TMR *)ptmr->OSTmrNext;               /* Point to next timer to update because current ... */
6454 fb55c b746          	tfr	d,y
6455 fb55e 18024582      	movw	5,y,OFST-5,s
6456                     ; 1121             if (OSTmrTime == ptmr->OSTmrMatch) {                 /* Process each timer that expires                   */
6458 fb562 fc13a5        	ldd	_OSTmrTime
6459 fb565 ac49          	cpd	9,y
6460 fb567 263a          	bne	L1673
6461 fb569 fc13a7        	ldd	_OSTmrTime+2
6462 fb56c ac4b          	cpd	11,y
6463 fb56e 2633          	bne	L1673
6464                     ; 1123                 OSTmr_Unlink(ptmr);                              /* Remove from current wheel spoke                   */
6467 fb570 ec80          	ldd	OFST-7,s
6468 fb572 1674ce        	jsr	L3562_OSTmr_Unlink
6470                     ; 1124                 if (ptmr->OSTmrOpt == OS_TMR_OPT_PERIODIC) {
6472 fb575 ed80          	ldy	OFST-7,s
6473 fb577 e6e815        	ldab	21,y
6474 fb57a c102          	cmpb	#2
6475 fb57c 260f          	bne	L3673
6476                     ; 1125                     OSTmr_Link(ptmr, OS_TMR_LINK_PERIODIC);      /* Recalculate new position of timer in wheel        */
6478 fb57e cc0001        	ldd	#1
6479 fb581 3b            	pshd	
6480 fb582 b764          	tfr	y,d
6481 fb584 167466        	jsr	L1562_OSTmr_Link
6483 fb587 1b82          	leas	2,s
6485 fb589 ed80          	ldy	OFST-7,s
6486 fb58b 2005          	bra	L5673
6487 fb58d               L3673:
6488                     ; 1127                     ptmr->OSTmrState = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
6490 fb58d c602          	ldab	#2
6491 fb58f 6be816        	stab	22,y
6492 fb592               L5673:
6493                     ; 1129                 pfnct = ptmr->OSTmrCallback;                     /* Execute callback function if available            */
6495 fb592 ec41          	ldd	1,y
6496 fb594 6c84          	std	OFST-3,s
6497                     ; 1130                 if (pfnct != (OS_TMR_CALLBACK)0) {
6499 fb596 270b          	beq	L1673
6500                     ; 1131                     (*pfnct)((void *)ptmr, ptmr->OSTmrCallbackArg);
6502 fb598 ec43          	ldd	3,y
6503 fb59a 3b            	pshd	
6504 fb59b ec82          	ldd	OFST-5,s
6505 fb59d 15f30006      	jsr	[OFST-1,s]
6507 fb5a1 1b82          	leas	2,s
6508 fb5a3               L1673:
6509                     ; 1134             ptmr = ptmr_next;
6511 fb5a3 ec82          	ldd	OFST-5,s
6512 fb5a5               L5573:
6513 fb5a5 6c80          	std	OFST-7,s
6514                     ; 1118         while (ptmr != (OS_TMR *)0) {
6516 fb5a7 26b3          	bne	L1573
6517                     ; 1136         OSSchedUnlock();
6519 fb5a9 1644d8        	jsr	_OSSchedUnlock
6522 fb5ac 067527        	bra	L5473
6534                     	xdef	_OSTmr_Init
6535                     	xref	_OS_MemClr
6536                     	xref	_OSSchedUnlock
6537                     	xref	_OSSchedLock
6538                     	xdef	_OSTmrSignal
6539                     	xdef	_OSTmrStop
6540                     	xdef	_OSTmrStart
6541                     	xdef	_OSTmrStateGet
6542                     	xdef	_OSTmrRemainGet
6543                     	xdef	_OSTmrDel
6544                     	xdef	_OSTmrCreate
6545                     	xref	_OSTaskNameSet
6546                     	xref	_OSTaskCreateExt
6547                     	xref	_OSSemPost
6548                     	xref	_OSSemPend
6549                     	xref	_OSSemCreate
6550                     	xref	_OSEventNameSet
6551                     	xref	_OSTmrWheelTbl
6552                     	xref	_OSTmrTaskStk
6553                     	xref	_OSTmrFreeList
6554                     	xref	_OSTmrTbl
6555                     	xref	_OSTmrSemSignal
6556                     	xref	_OSTmrSem
6557                     	xref	_OSTmrTime
6558                     	xref	_OSTmrUsed
6559                     	xref	_OSTmrFree
6560                     	xref	_OSIntNesting
6561                     .const:	section	.data
6562 fb745               L7253:
6563 fb745 75432f4f532d  	dc.b	"uC/OS-II Tmr",0
6564 fb752               L1153:
6565 fb752 75432f4f532d  	dc.b	"uC/OS-II TmrSignal",0
6566 fb765               L7053:
6567 fb765 75432f4f532d  	dc.b	"uC/OS-II TmrLock",0
6588                     	xref	c_ladd
6589                     	xref	c_lsub
6590                     	end
