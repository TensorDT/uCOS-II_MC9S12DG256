   1                     ; C Compiler for 68HCS12 [COSMIC Software]
   2                     ; Parser V4.11.9 - 08 Feb 2017
   3                     ; Generator V4.8.12 - 22 Feb 2017
   4                     ; Optimizer V4.7.11 - 22 Feb 2017
4109                     ; 93 _NEAR BOOLEAN  OSMutexAccept (OS_EVENT  *pevent,
4109                     ; 94                              INT8U     *perr)
4109                     ; 95 {
4110                     	switch	.text
4111 f9907               _OSMutexAccept:
4113 f9907 3b            	pshd	
4114       00000002      OFST:	set	2
4117                     ; 98     OS_CPU_SR  cpu_sr = 0u;
4119                     ; 111     if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
4121 f9908 6cae          	std	2,-s
4122 f990a 2604          	bne	L1372
4123                     ; 112         *perr = OS_ERR_PEVENT_NULL;
4125 f990c c604          	ldab	#4
4126                     ; 113         return (OS_FALSE);
4129 f990e 200a          	bra	LC001
4130 f9910               L1372:
4131                     ; 116     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
4133 f9910 e6f30002      	ldab	[OFST+0,s]
4134 f9914 c104          	cmpb	#4
4135 f9916 270a          	beq	L3372
4136                     ; 117         *perr = OS_ERR_EVENT_TYPE;
4138 f9918 c601          	ldab	#1
4139                     ; 118         return (OS_FALSE);
4141 f991a               LC001:
4142 f991a 6bf30006      	stab	[OFST+4,s]
4143 f991e c7            	clrb	
4145 f991f               L6:
4147 f991f 1b84          	leas	4,s
4148 f9921 3d            	rts	
4149 f9922               L3372:
4150                     ; 120     if (OSIntNesting > 0u) {                           /* Make sure it's not called from an ISR        */
4152 f9922 f6163c        	ldab	_OSIntNesting
4153 f9925 2704          	beq	L5372
4154                     ; 121         *perr = OS_ERR_PEND_ISR;
4156 f9927 c602          	ldab	#2
4157                     ; 122         return (OS_FALSE);
4160 f9929 20ef          	bra	LC001
4161 f992b               L5372:
4162                     ; 124     OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
4164 f992b 164b4f        	jsr	_OS_CPU_SR_Save
4166 f992e 6b80          	stab	OFST-2,s
4167                     ; 125     pcp = (INT8U)(pevent->OSEventCnt >> 8u);           /* Get PCP from mutex                           */
4169 f9930 ed82          	ldy	OFST+0,s
4170 f9932 180a4381      	movb	3,y,OFST-1,s
4171                     ; 126     if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
4173 f9936 e644          	ldab	4,y
4174 f9938 87            	clra	
4175 f9939 8c00ff        	cpd	#255
4176 f993c 263a          	bne	L7372
4177                     ; 127         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
4179 f993e 6a44          	staa	4,y
4180                     ; 128         pevent->OSEventCnt |= (INT16U)OSTCBCur->OSTCBPrio;  /* Save current task priority in LSByte    */
4182 f9940 fe1588        	ldx	_OSTCBCur
4183 f9943 e6e024        	ldab	36,x
4184 f9946 ea44          	orab	4,y
4185 f9948 aa43          	oraa	3,y
4186 f994a 6c43          	std	3,y
4187                     ; 129         pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
4189 f994c 6e41          	stx	1,y
4190                     ; 130         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
4190                     ; 131             (OSTCBCur->OSTCBPrio <= pcp)) {            /*      PCP 'must' have a SMALLER prio ...      */
4192 f994e e681          	ldab	OFST-1,s
4193 f9950 048117        	ibeq	b,L1472
4195 f9953 b756          	tfr	x,y
4196 f9955 e6e824        	ldab	36,y
4197 f9958 e181          	cmpb	OFST-1,s
4198 f995a 220e          	bhi	L1472
4199                     ; 132              OS_EXIT_CRITICAL();                       /*      ... than current task!                  */
4201 f995c e680          	ldab	OFST-2,s
4202 f995e 87            	clra	
4203 f995f 164b54        	jsr	_OS_CPU_SR_Restore
4205                     ; 133             *perr = OS_ERR_PCP_LOWER;
4207 f9962 c678          	ldab	#120
4208 f9964 6bf30006      	stab	[OFST+4,s]
4210 f9968 200a          	bra	L3472
4211 f996a               L1472:
4212                     ; 135              OS_EXIT_CRITICAL();
4214 f996a e680          	ldab	OFST-2,s
4215 f996c 87            	clra	
4216 f996d 164b54        	jsr	_OS_CPU_SR_Restore
4218                     ; 136             *perr = OS_ERR_NONE;
4220 f9970 69f30006      	clr	[OFST+4,s]
4221 f9974               L3472:
4222                     ; 138         return (OS_TRUE);
4224 f9974 c601          	ldab	#1
4226 f9976 20a7          	bra	L6
4227 f9978               L7372:
4228                     ; 140     OS_EXIT_CRITICAL();
4230 f9978 e680          	ldab	OFST-2,s
4231 f997a 164b54        	jsr	_OS_CPU_SR_Restore
4233                     ; 141     *perr = OS_ERR_NONE;
4235 f997d c7            	clrb	
4236 f997e 6bf30006      	stab	[OFST+4,s]
4237                     ; 142     return (OS_FALSE);
4241 f9982 1b84          	leas	4,s
4242 f9984 3d            	rts	
4311                     ; 187 _NEAR OS_EVENT  *OSMutexCreate (INT8U   prio,
4311                     ; 188                                INT8U  *perr)
4311                     ; 189 {
4312                     	switch	.text
4313 f9985               _OSMutexCreate:
4315 f9985 3b            	pshd	
4316 f9986 1b9d          	leas	-3,s
4317       00000003      OFST:	set	3
4320                     ; 192     OS_CPU_SR  cpu_sr = 0u;
4322                     ; 213     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
4324 f9988 c1ff          	cmpb	#255
4325 f998a 2708          	beq	L7772
4326                     ; 214         if (prio >= OS_LOWEST_PRIO) {                      /* Validate PCP                             */
4328 f998c c13f          	cmpb	#63
4329 f998e 2504          	blo	L7772
4330                     ; 215            *perr = OS_ERR_PRIO_INVALID;
4332 f9990 c62a          	ldab	#42
4333                     ; 216             return ((OS_EVENT *)0);
4336 f9992 2007          	bra	LC002
4337 f9994               L7772:
4338                     ; 220     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
4340 f9994 f6163c        	ldab	_OSIntNesting
4341 f9997 270b          	beq	L3003
4342                     ; 221         *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
4344 f9999 c610          	ldab	#16
4345                     ; 222         return ((OS_EVENT *)0);
4347 f999b               LC002:
4348 f999b 6bf30007      	stab	[OFST+4,s]
4349 f999f 87            	clra	
4350 f99a0 c7            	clrb	
4352 f99a1               L21:
4354 f99a1 1b85          	leas	5,s
4355 f99a3 3d            	rts	
4356 f99a4               L3003:
4357                     ; 224     OS_ENTER_CRITICAL();
4359 f99a4 164b4f        	jsr	_OS_CPU_SR_Save
4361 f99a7 6b82          	stab	OFST-1,s
4362                     ; 225     if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
4364 f99a9 e684          	ldab	OFST+1,s
4365 f99ab c1ff          	cmpb	#255
4366 f99ad 2720          	beq	L5003
4367                     ; 226         if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {           /* Mutex priority must not already exist    */
4369 f99af 87            	clra	
4370 f99b0 59            	lsld	
4371 f99b1 b746          	tfr	d,y
4372 f99b3 ecea1502      	ldd	_OSTCBPrioTbl,y
4373 f99b7 270a          	beq	L7003
4374                     ; 227             OS_EXIT_CRITICAL();                            /* Task already exist at priority ...       */
4376 f99b9 e682          	ldab	OFST-1,s
4377 f99bb 87            	clra	
4378 f99bc 164b54        	jsr	_OS_CPU_SR_Restore
4380                     ; 228            *perr = OS_ERR_PRIO_EXIST;                      /* ... ceiling priority                     */
4382 f99bf c628          	ldab	#40
4383                     ; 229             return ((OS_EVENT *)0);
4386 f99c1 20d8          	bra	LC002
4387 f99c3               L7003:
4388                     ; 231         OSTCBPrioTbl[prio] = OS_TCB_RESERVED;              /* Reserve the table entry                  */
4390 f99c3 e684          	ldab	OFST+1,s
4391 f99c5 59            	lsld	
4392 f99c6 b746          	tfr	d,y
4393 f99c8 cc0001        	ldd	#1
4394 f99cb 6cea1502      	std	_OSTCBPrioTbl,y
4395 f99cf               L5003:
4396                     ; 234     pevent = OSEventFreeList;                              /* Get next free event control block        */
4398 f99cf fc1702        	ldd	_OSEventFreeList
4399 f99d2 6c80          	std	OFST-3,s
4400                     ; 235     if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
4402 f99d4 261f          	bne	L1103
4403                     ; 236         if (prio != OS_PRIO_MUTEX_CEIL_DIS) {
4405 f99d6 e684          	ldab	OFST+1,s
4406 f99d8 c1ff          	cmpb	#255
4407 f99da 2709          	beq	L3103
4408                     ; 237             OSTCBPrioTbl[prio] = (OS_TCB *)0;              /* No, Release the table entry              */
4410 f99dc 59            	lsld	
4411 f99dd b746          	tfr	d,y
4412 f99df 87            	clra	
4413 f99e0 c7            	clrb	
4414 f99e1 6cea1502      	std	_OSTCBPrioTbl,y
4415 f99e5               L3103:
4416                     ; 239         OS_EXIT_CRITICAL();
4418 f99e5 e682          	ldab	OFST-1,s
4419 f99e7 87            	clra	
4420 f99e8 164b54        	jsr	_OS_CPU_SR_Restore
4422                     ; 240        *perr = OS_ERR_PEVENT_NULL;                         /* No more event control blocks             */
4424 f99eb c604          	ldab	#4
4425 f99ed 6bf30007      	stab	[OFST+4,s]
4426                     ; 241         return (pevent);
4428 f99f1 ec80          	ldd	OFST-3,s
4430 f99f3 20ac          	bra	L21
4431 f99f5               L1103:
4432                     ; 243     OSEventFreeList     = (OS_EVENT *)OSEventFreeList->OSEventPtr; /* Adjust the free list             */
4434 f99f5 b746          	tfr	d,y
4435 f99f7 1805411702    	movw	1,y,_OSEventFreeList
4436                     ; 244     OS_EXIT_CRITICAL();
4438 f99fc e682          	ldab	OFST-1,s
4439 f99fe 87            	clra	
4440 f99ff 164b54        	jsr	_OS_CPU_SR_Restore
4442                     ; 245     pevent->OSEventType = OS_EVENT_TYPE_MUTEX;
4444 f9a02 c604          	ldab	#4
4445 f9a04 ed80          	ldy	OFST-3,s
4446 f9a06 6b40          	stab	0,y
4447                     ; 246     pevent->OSEventCnt  = (INT16U)((INT16U)prio << 8u) | OS_MUTEX_AVAILABLE; /* Resource is avail.     */
4449 f9a08 cc00ff        	ldd	#255
4450 f9a0b aa84          	oraa	OFST+1,s
4451 f9a0d 6c43          	std	3,y
4452                     ; 247     pevent->OSEventPtr  = (void *)0;                       /* No task owning the mutex                 */
4454 f9a0f 87            	clra	
4455 f9a10 c7            	clrb	
4456 f9a11 6c41          	std	1,y
4457                     ; 249     pevent->OSEventName = (INT8U *)(void *)"?";
4459 f9a13 cc773d        	ldd	#L5103
4460 f9a16 6c4e          	std	14,y
4461                     ; 251     OS_EventWaitListInit(pevent);
4463 f9a18 b764          	tfr	y,d
4464 f9a1a 1647a9        	jsr	_OS_EventWaitListInit
4466                     ; 253    *perr = OS_ERR_NONE;
4469 f9a1d 69f30007      	clr	[OFST+4,s]
4470                     ; 254     return (pevent);
4472 f9a21 ec80          	ldd	OFST-3,s
4475 f9a23 1b85          	leas	5,s
4476 f9a25 3d            	rts	
4912                     ; 301 _NEAR OS_EVENT  *OSMutexDel (OS_EVENT  *pevent,
4912                     ; 302                             INT8U      opt,
4912                     ; 303                             INT8U     *perr)
4912                     ; 304 {
4913                     	switch	.text
4914 f9a26               _OSMutexDel:
4916 f9a26 3b            	pshd	
4917 f9a27 1b9a          	leas	-6,s
4918       00000006      OFST:	set	6
4921                     ; 311     OS_CPU_SR  cpu_sr = 0u;
4923                     ; 331     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
4925 f9a29 046404        	tbne	d,L3723
4926                     ; 332         *perr = OS_ERR_PEVENT_NULL;
4928 f9a2c c604          	ldab	#4
4929                     ; 333         return (pevent);
4932 f9a2e 200a          	bra	L61
4933 f9a30               L3723:
4934                     ; 339     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
4937 f9a30 e6f30006      	ldab	[OFST+0,s]
4938 f9a34 c104          	cmpb	#4
4939 f9a36 270b          	beq	L5723
4940                     ; 340         *perr = OS_ERR_EVENT_TYPE;
4942 f9a38 c601          	ldab	#1
4943                     ; 342         return (pevent);
4947 f9a3a               L61:
4948 f9a3a 6bf3000c      	stab	[OFST+6,s]
4949 f9a3e ec86          	ldd	OFST+0,s
4951 f9a40 1b88          	leas	8,s
4952 f9a42 3d            	rts	
4953 f9a43               L5723:
4954                     ; 344     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
4956 f9a43 f6163c        	ldab	_OSIntNesting
4957 f9a46 2704          	beq	L7723
4958                     ; 345         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
4960 f9a48 c60f          	ldab	#15
4961                     ; 347         return (pevent);
4965 f9a4a 20ee          	bra	L61
4966 f9a4c               L7723:
4967                     ; 349     OS_ENTER_CRITICAL();
4969 f9a4c 164b4f        	jsr	_OS_CPU_SR_Save
4971 f9a4f 6b83          	stab	OFST-3,s
4972                     ; 350     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mutex        */
4974 f9a51 ed86          	ldy	OFST+0,s
4975 f9a53 e645          	ldab	5,y
4976 f9a55 2706          	beq	L1033
4977                     ; 351         tasks_waiting = OS_TRUE;                           /* Yes                                      */
4979 f9a57 c601          	ldab	#1
4980 f9a59 6b84          	stab	OFST-2,s
4982 f9a5b 2002          	bra	L3033
4983 f9a5d               L1033:
4984                     ; 353         tasks_waiting = OS_FALSE;                          /* No                                       */
4986 f9a5d 6984          	clr	OFST-2,s
4987 f9a5f               L3033:
4988                     ; 355     switch (opt) {
4990 f9a5f e68b          	ldab	OFST+5,s
4992 f9a61 270d          	beq	L7103
4993 f9a63 040154        	dbeq	b,L1203
4994                     ; 413         default:
4994                     ; 414              OS_EXIT_CRITICAL();
4996 f9a66 e683          	ldab	OFST-3,s
4997 f9a68 87            	clra	
4998 f9a69 164b54        	jsr	_OS_CPU_SR_Restore
5000                     ; 415              *perr         = OS_ERR_INVALID_OPT;
5002 f9a6c c607          	ldab	#7
5003                     ; 416              pevent_return = pevent;
5005                     ; 417              break;
5007 f9a6e 2040          	bra	LC004
5008 f9a70               L7103:
5009                     ; 356         case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
5009                     ; 357              if (tasks_waiting == OS_FALSE) {
5011 f9a70 e684          	ldab	OFST-2,s
5012 f9a72 2634          	bne	L1133
5013                     ; 359                  pevent->OSEventName   = (INT8U *)(void *)"?";
5015 f9a74 cc773d        	ldd	#L5103
5016 f9a77 6c4e          	std	14,y
5017                     ; 361                  pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
5019 f9a79 e643          	ldab	3,y
5020 f9a7b 6b82          	stab	OFST-4,s
5021                     ; 362                  if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
5023 f9a7d c1ff          	cmpb	#255
5024 f9a7f 270c          	beq	L3133
5025                     ; 363                      OSTCBPrioTbl[pcp] = (OS_TCB *)0;      /* Free up the PCP                          */
5027 f9a81 87            	clra	
5028 f9a82 59            	lsld	
5029 f9a83 b746          	tfr	d,y
5030 f9a85 87            	clra	
5031 f9a86 c7            	clrb	
5032 f9a87 6cea1502      	std	_OSTCBPrioTbl,y
5033 f9a8b ed86          	ldy	OFST+0,s
5034 f9a8d               L3133:
5035                     ; 365                  pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
5037 f9a8d 87            	clra	
5038 f9a8e 6a40          	staa	0,y
5039                     ; 366                  pevent->OSEventPtr    = OSEventFreeList;  /* Return Event Control Block to free list  */
5041 f9a90 1801411702    	movw	_OSEventFreeList,1,y
5042                     ; 367                  pevent->OSEventCnt    = 0u;
5044 f9a95 c7            	clrb	
5045 f9a96 6c43          	std	3,y
5046                     ; 368                  OSEventFreeList       = pevent;
5048 f9a98 7d1702        	sty	_OSEventFreeList
5049                     ; 369                  OS_EXIT_CRITICAL();
5051 f9a9b e683          	ldab	OFST-3,s
5052 f9a9d 164b54        	jsr	_OS_CPU_SR_Restore
5054                     ; 370                  *perr                 = OS_ERR_NONE;
5056 f9aa0 87            	clra	
5057 f9aa1 6af3000c      	staa	[OFST+6,s]
5058                     ; 371                  pevent_return         = (OS_EVENT *)0;    /* Mutex has been deleted                   */
5060 f9aa5 c7            	clrb	
5062 f9aa6 200e          	bra	LC003
5063 f9aa8               L1133:
5064                     ; 373                  OS_EXIT_CRITICAL();
5066 f9aa8 e683          	ldab	OFST-3,s
5067 f9aaa 87            	clra	
5068 f9aab 164b54        	jsr	_OS_CPU_SR_Restore
5070                     ; 374                  *perr                 = OS_ERR_TASK_WAITING;
5072 f9aae c649          	ldab	#73
5073                     ; 375                  pevent_return         = pevent;
5075 f9ab0               LC004:
5076 f9ab0 6bf3000c      	stab	[OFST+6,s]
5077 f9ab4 ec86          	ldd	OFST+0,s
5078 f9ab6               LC003:
5079 f9ab6 6c80          	std	OFST-6,s
5080 f9ab8 2075          	bra	L7033
5081 f9aba               L1203:
5082                     ; 379         case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
5082                     ; 380              pcp  = (INT8U)(pevent->OSEventCnt >> 8u);                       /* Get PCP of mutex       */
5084 f9aba e643          	ldab	3,y
5085 f9abc 6b82          	stab	OFST-4,s
5086                     ; 381              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
5088 f9abe 04812e        	ibeq	b,L7233
5089                     ; 382                  prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /* Get owner's orig prio  */
5091 f9ac1 180a4485      	movb	4,y,OFST-1,s
5092                     ; 383                  ptcb = (OS_TCB *)pevent->OSEventPtr;
5094 f9ac5 ed41          	ldy	1,y
5095 f9ac7 6d80          	sty	OFST-6,s
5096                     ; 384                  if (ptcb != (OS_TCB *)0) {                /* See if any task owns the mutex           */
5098 f9ac9 2724          	beq	L7233
5099                     ; 385                      if (ptcb->OSTCBPrio == pcp) {         /* See if original prio was changed         */
5101 f9acb e6e824        	ldab	36,y
5102 f9ace e182          	cmpb	OFST-4,s
5103 f9ad0 261d          	bne	L7233
5104                     ; 387                          OSMutex_RdyAtPrio(ptcb, prio);    /* Yes, Restore the task's original prio    */
5107 f9ad2 e685          	ldab	OFST-1,s
5108 f9ad4 87            	clra	
5109 f9ad5 3b            	pshd	
5110 f9ad6 b764          	tfr	y,d
5111 f9ad8 165e48        	jsr	L3462_OSMutex_RdyAtPrio
5113 f9adb 1b82          	leas	2,s
5114 f9add 2010          	bra	L7233
5115 f9adf               L5233:
5116                     ; 392                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_ABORT);
5118 f9adf cc0002        	ldd	#2
5119 f9ae2 3b            	pshd	
5120 f9ae3 c610          	ldab	#16
5121 f9ae5 3b            	pshd	
5122 f9ae6 c7            	clrb	
5123 f9ae7 3b            	pshd	
5124 f9ae8 b764          	tfr	y,d
5125 f9aea 1645fc        	jsr	_OS_EventTaskRdy
5127 f9aed 1b86          	leas	6,s
5128 f9aef               L7233:
5129                     ; 391              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mutex        */
5131 f9aef ed86          	ldy	OFST+0,s
5132 f9af1 e645          	ldab	5,y
5133 f9af3 26ea          	bne	L5233
5134                     ; 395              pevent->OSEventName   = (INT8U *)(void *)"?";
5136 f9af5 cc773d        	ldd	#L5103
5137 f9af8 6c4e          	std	14,y
5138                     ; 397              pcp                   = (INT8U)(pevent->OSEventCnt >> 8u);
5140 f9afa e643          	ldab	3,y
5141 f9afc 6b82          	stab	OFST-4,s
5142                     ; 398              if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
5144 f9afe c1ff          	cmpb	#255
5145 f9b00 270c          	beq	L3333
5146                     ; 399                  OSTCBPrioTbl[pcp] = (OS_TCB *)0;          /* Free up the PCP                          */
5148 f9b02 87            	clra	
5149 f9b03 59            	lsld	
5150 f9b04 b746          	tfr	d,y
5151 f9b06 87            	clra	
5152 f9b07 c7            	clrb	
5153 f9b08 6cea1502      	std	_OSTCBPrioTbl,y
5154 f9b0c ed86          	ldy	OFST+0,s
5155 f9b0e               L3333:
5156                     ; 401              pevent->OSEventType   = OS_EVENT_TYPE_UNUSED;
5158 f9b0e 87            	clra	
5159 f9b0f 6a40          	staa	0,y
5160                     ; 402              pevent->OSEventPtr    = OSEventFreeList;      /* Return Event Control Block to free list  */
5162 f9b11 1801411702    	movw	_OSEventFreeList,1,y
5163                     ; 403              pevent->OSEventCnt    = 0u;
5165 f9b16 c7            	clrb	
5166 f9b17 6c43          	std	3,y
5167                     ; 404              OSEventFreeList       = pevent;               /* Get next free event control block        */
5169 f9b19 7d1702        	sty	_OSEventFreeList
5170                     ; 405              OS_EXIT_CRITICAL();
5172 f9b1c e683          	ldab	OFST-3,s
5173 f9b1e 164b54        	jsr	_OS_CPU_SR_Restore
5175                     ; 406              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
5177 f9b21 e684          	ldab	OFST-2,s
5178 f9b23 042103        	dbne	b,L5333
5179                     ; 407                  OS_Sched();                               /* Find highest priority task ready to run  */
5181 f9b26 164933        	jsr	_OS_Sched
5183 f9b29               L5333:
5184                     ; 409              *perr         = OS_ERR_NONE;
5186 f9b29 87            	clra	
5187 f9b2a 6af3000c      	staa	[OFST+6,s]
5188                     ; 410              pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
5190 f9b2e c7            	clrb	
5191                     ; 411              break;
5193 f9b2f               L7033:
5194                     ; 422     return (pevent_return);
5199 f9b2f 1b88          	leas	8,s
5200 f9b31 3d            	rts	
5323                     ; 467 _NEAR void  OSMutexPend (OS_EVENT  *pevent,
5323                     ; 468                         INT32U     timeout,
5323                     ; 469                         INT8U     *perr)
5323                     ; 470 {
5324                     	switch	.text
5325 f9b32               _OSMutexPend:
5327 f9b32 3b            	pshd	
5328 f9b33 1b99          	leas	-7,s
5329       00000007      OFST:	set	7
5332                     ; 478     OS_CPU_SR  cpu_sr = 0u;
5334                     ; 490     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
5336 f9b35 046404        	tbne	d,L1243
5337                     ; 491         *perr = OS_ERR_PEVENT_NULL;
5339 f9b38 c604          	ldab	#4
5340                     ; 492         return;
5342 f9b3a 200a          	bra	LC005
5343 f9b3c               L1243:
5344                     ; 498     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
5347 f9b3c e6f30007      	ldab	[OFST+0,s]
5348 f9b40 c104          	cmpb	#4
5349 f9b42 2709          	beq	L3243
5350                     ; 499         *perr = OS_ERR_EVENT_TYPE;
5352 f9b44 c601          	ldab	#1
5353 f9b46               LC005:
5354 f9b46 6bf3000f      	stab	[OFST+8,s]
5355                     ; 501         return;
5356 f9b4a               L23:
5360 f9b4a 1b89          	leas	9,s
5361 f9b4c 3d            	rts	
5362 f9b4d               L3243:
5363                     ; 503     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
5365 f9b4d f6163c        	ldab	_OSIntNesting
5366 f9b50 2704          	beq	L5243
5367                     ; 504         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
5369 f9b52 c602          	ldab	#2
5370                     ; 506         return;
5373 f9b54 20f0          	bra	LC005
5374 f9b56               L5243:
5375                     ; 508     if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
5377 f9b56 f6163b        	ldab	_OSLockNesting
5378 f9b59 2704          	beq	L7243
5379                     ; 509         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
5381 f9b5b c60d          	ldab	#13
5382                     ; 511         return;
5385 f9b5d 20e7          	bra	LC005
5386 f9b5f               L7243:
5387                     ; 514     OS_ENTER_CRITICAL();
5389 f9b5f 164b4f        	jsr	_OS_CPU_SR_Save
5391 f9b62 6b86          	stab	OFST-1,s
5392                     ; 515     pcp = (INT8U)(pevent->OSEventCnt >> 8u);               /* Get PCP from mutex                       */
5394 f9b64 ed87          	ldy	OFST+0,s
5395 f9b66 180a4385      	movb	3,y,OFST-2,s
5396                     ; 517     if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
5398 f9b6a e644          	ldab	4,y
5399 f9b6c 04a135        	ibne	b,L1343
5400                     ; 518         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
5402 f9b6f 87            	clra	
5403 f9b70 6a44          	staa	4,y
5404                     ; 519         pevent->OSEventCnt |= (INT16U)OSTCBCur->OSTCBPrio; /*      Save priority of owning task        */
5406 f9b72 fe1588        	ldx	_OSTCBCur
5407 f9b75 e6e024        	ldab	36,x
5408 f9b78 ea44          	orab	4,y
5409 f9b7a aa43          	oraa	3,y
5410 f9b7c 6c43          	std	3,y
5411                     ; 520         pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
5413 f9b7e 6e41          	stx	1,y
5414                     ; 521         if ((pcp != OS_PRIO_MUTEX_CEIL_DIS) &&
5414                     ; 522             (OSTCBCur->OSTCBPrio <= pcp)) {                /*      PCP 'must' have a SMALLER prio ...  */
5416 f9b80 e685          	ldab	OFST-2,s
5417 f9b82 048113        	ibeq	b,L3343
5419 f9b85 b756          	tfr	x,y
5420 f9b87 e6e824        	ldab	36,y
5421 f9b8a e185          	cmpb	OFST-2,s
5422 f9b8c 220a          	bhi	L3343
5423                     ; 523              OS_EXIT_CRITICAL();                           /*      ... than current task!              */
5425 f9b8e e686          	ldab	OFST-1,s
5426 f9b90 87            	clra	
5427 f9b91 164b54        	jsr	_OS_CPU_SR_Restore
5429                     ; 524             *perr = OS_ERR_PCP_LOWER;
5431 f9b94 c678          	ldab	#120
5433 f9b96 20ae          	bra	LC005
5434 f9b98               L3343:
5435                     ; 526              OS_EXIT_CRITICAL();
5437 f9b98 e686          	ldab	OFST-1,s
5438 f9b9a 87            	clra	
5439 f9b9b 164b54        	jsr	_OS_CPU_SR_Restore
5441                     ; 527             *perr = OS_ERR_NONE;
5443 f9b9e 69f3000f      	clr	[OFST+8,s]
5444                     ; 530         return;
5447 f9ba2 20a6          	bra	L23
5448 f9ba4               L1343:
5449                     ; 532     if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
5451 f9ba4 e685          	ldab	OFST-2,s
5452 f9ba6 52            	incb	
5453 f9ba7 182700f4      	beq	L7343
5454                     ; 533         mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8); /*  Get priority of mutex owner   */
5456 f9bab 180a4482      	movb	4,y,OFST-5,s
5457                     ; 534         ptcb  = (OS_TCB *)(pevent->OSEventPtr);                   /*     Point to TCB of mutex owner   */
5459 f9baf ed41          	ldy	1,y
5460 f9bb1 6d80          	sty	OFST-7,s
5461                     ; 535         if (ptcb->OSTCBPrio > pcp) {                              /*     Need to promote prio of owner?*/
5463 f9bb3 e6e824        	ldab	36,y
5464 f9bb6 e185          	cmpb	OFST-2,s
5465 f9bb8 182300e3      	bls	L7343
5466                     ; 536             if (mprio > OSTCBCur->OSTCBPrio) {
5468 f9bbc e682          	ldab	OFST-5,s
5469 f9bbe fd1588        	ldy	_OSTCBCur
5470 f9bc1 e1e824        	cmpb	36,y
5471 f9bc4 182300d7      	bls	L7343
5472                     ; 537                 y = ptcb->OSTCBY;
5474 f9bc8 ed80          	ldy	OFST-7,s
5475 f9bca e6e826        	ldab	38,y
5476 f9bcd 6b82          	stab	OFST-5,s
5477                     ; 538                 if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0u) {      /*     See if mutex owner is ready   */
5479 f9bcf b796          	exg	b,y
5480 f9bd1 ee80          	ldx	OFST-7,s
5481 f9bd3 e6e027        	ldab	39,x
5482 f9bd6 e4ea1630      	andb	_OSRdyTbl,y
5483 f9bda 2720          	beq	L5443
5484                     ; 539                     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;     /*     Yes, Remove owner from Rdy ...*/
5486 f9bdc e6e027        	ldab	39,x
5487 f9bdf 51            	comb	
5488 f9be0 e4ea1630      	andb	_OSRdyTbl,y
5489 f9be4 6bea1630      	stab	_OSRdyTbl,y
5490                     ; 540                     if (OSRdyTbl[y] == 0u) {                      /*          ... list at current prio */
5492 f9be8 260c          	bne	L7443
5493                     ; 541                         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
5495 f9bea b756          	tfr	x,y
5496 f9bec e6e828        	ldab	40,y
5497 f9bef 51            	comb	
5498 f9bf0 f41638        	andb	_OSRdyGrp
5499 f9bf3 7b1638        	stab	_OSRdyGrp
5500 f9bf6               L7443:
5501                     ; 543                     rdy = OS_TRUE;
5503 f9bf6 c601          	ldab	#1
5504 f9bf8 6b82          	stab	OFST-5,s
5506 f9bfa 2028          	bra	L1543
5507 f9bfc               L5443:
5508                     ; 545                     pevent2 = ptcb->OSTCBEventPtr;
5510 f9bfc b756          	tfr	x,y
5511 f9bfe ece812        	ldd	18,y
5512 f9c01 6c83          	std	OFST-4,s
5513                     ; 546                     if (pevent2 != (OS_EVENT *)0) {               /* Remove from event wait list       */
5515 f9c03 271d          	beq	L3543
5516                     ; 547                         y = ptcb->OSTCBY;
5518 f9c05 e6e826        	ldab	38,y
5519 f9c08 6b82          	stab	OFST-5,s
5520                     ; 548                         pevent2->OSEventTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
5522 f9c0a ed83          	ldy	OFST-4,s
5523 f9c0c 19ed          	leay	b,y
5524 f9c0e e6e027        	ldab	39,x
5525 f9c11 51            	comb	
5526 f9c12 e446          	andb	6,y
5527 f9c14 6b46          	stab	6,y
5528                     ; 549                         if (pevent2->OSEventTbl[y] == 0u) {
5530 f9c16 260a          	bne	L3543
5531                     ; 550                             pevent2->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
5533 f9c18 ed83          	ldy	OFST-4,s
5534 f9c1a e6e028        	ldab	40,x
5535 f9c1d 51            	comb	
5536 f9c1e e445          	andb	5,y
5537 f9c20 6b45          	stab	5,y
5538 f9c22               L3543:
5539                     ; 553                     rdy = OS_FALSE;                        /* No                                       */
5541 f9c22 6982          	clr	OFST-5,s
5542 f9c24               L1543:
5543                     ; 555                 ptcb->OSTCBPrio = pcp;                     /* Change owner task prio to PCP            */
5545 f9c24 e685          	ldab	OFST-2,s
5546 f9c26 ed80          	ldy	OFST-7,s
5547 f9c28 6be824        	stab	36,y
5548                     ; 560                 ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3u);
5551 f9c2b 54            	lsrb	
5552 f9c2c 54            	lsrb	
5553 f9c2d 54            	lsrb	
5554 f9c2e 6be826        	stab	38,y
5555                     ; 561                 ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07u);
5557 f9c31 e6e824        	ldab	36,y
5558 f9c34 c407          	andb	#7
5559 f9c36 6be825        	stab	37,y
5560                     ; 566                 ptcb->OSTCBBitY = (OS_PRIO)(1uL << ptcb->OSTCBY);
5562 f9c39 c601          	ldab	#1
5563 f9c3b a6e826        	ldaa	38,y
5564 f9c3e 2704          	beq	L22
5565 f9c40               L42:
5566 f9c40 58            	lslb	
5567 f9c41 0430fc        	dbne	a,L42
5568 f9c44               L22:
5569 f9c44 6be828        	stab	40,y
5570                     ; 567                 ptcb->OSTCBBitX = (OS_PRIO)(1uL << ptcb->OSTCBX);
5572 f9c47 c601          	ldab	#1
5573 f9c49 a6e825        	ldaa	37,y
5574 f9c4c 2704          	beq	L62
5575 f9c4e               L03:
5576 f9c4e 58            	lslb	
5577 f9c4f 0430fc        	dbne	a,L03
5578 f9c52               L62:
5579 f9c52 6be827        	stab	39,y
5580                     ; 569                 if (rdy == OS_TRUE) {                      /* If task was ready at owner's priority ...*/
5582 f9c55 e682          	ldab	OFST-5,s
5583 f9c57 04211d        	dbne	b,L7543
5584                     ; 570                     OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.   */
5586 f9c5a e6e828        	ldab	40,y
5587 f9c5d fa1638        	orab	_OSRdyGrp
5588 f9c60 7b1638        	stab	_OSRdyGrp
5589                     ; 571                     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
5591 f9c63 e6e826        	ldab	38,y
5592 f9c66 b796          	exg	b,y
5593 f9c68 ee80          	ldx	OFST-7,s
5594 f9c6a e6e027        	ldab	39,x
5595 f9c6d eaea1630      	orab	_OSRdyTbl,y
5596 f9c71 6bea1630      	stab	_OSRdyTbl,y
5598 f9c75 201c          	bra	L1643
5599 f9c77               L7543:
5600                     ; 573                     pevent2 = ptcb->OSTCBEventPtr;
5602 f9c77 ede812        	ldy	18,y
5603 f9c7a 6d83          	sty	OFST-4,s
5604                     ; 574                     if (pevent2 != (OS_EVENT *)0) {        /* Add to event wait list                   */
5606 f9c7c 2715          	beq	L1643
5607                     ; 575                         pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
5609 f9c7e ee80          	ldx	OFST-7,s
5610 f9c80 e6e028        	ldab	40,x
5611 f9c83 ea45          	orab	5,y
5612 f9c85 6b45          	stab	5,y
5613                     ; 576                         pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
5615 f9c87 e6e026        	ldab	38,x
5616 f9c8a 19ed          	leay	b,y
5617 f9c8c e6e027        	ldab	39,x
5618 f9c8f ea46          	orab	6,y
5619 f9c91 6b46          	stab	6,y
5620 f9c93               L1643:
5621                     ; 579                 OSTCBPrioTbl[pcp] = ptcb;
5623 f9c93 e685          	ldab	OFST-2,s
5624 f9c95 87            	clra	
5625 f9c96 59            	lsld	
5626 f9c97 b746          	tfr	d,y
5627 f9c99 ec80          	ldd	OFST-7,s
5628 f9c9b 6cea1502      	std	_OSTCBPrioTbl,y
5629 f9c9f               L7343:
5630                     ; 583     OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
5632 f9c9f fd1588        	ldy	_OSTCBCur
5633 f9ca2 0ce82210      	bset	34,y,16
5634                     ; 584     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
5636 f9ca6 69e823        	clr	35,y
5637                     ; 585     OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
5639 f9ca9 ec8d          	ldd	OFST+6,s
5640 f9cab 6ce820        	std	32,y
5641 f9cae ec8b          	ldd	OFST+4,s
5642 f9cb0 6ce81e        	std	30,y
5643                     ; 586     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
5645 f9cb3 ec87          	ldd	OFST+0,s
5646 f9cb5 164690        	jsr	_OS_EventTaskWait
5648                     ; 587     OS_EXIT_CRITICAL();
5650 f9cb8 e686          	ldab	OFST-1,s
5651 f9cba 87            	clra	
5652 f9cbb 164b54        	jsr	_OS_CPU_SR_Restore
5654                     ; 588     OS_Sched();                                       /* Find next highest priority task ready         */
5656 f9cbe 164933        	jsr	_OS_Sched
5658                     ; 589     OS_ENTER_CRITICAL();
5660 f9cc1 164b4f        	jsr	_OS_CPU_SR_Save
5662 f9cc4 6b86          	stab	OFST-1,s
5663                     ; 590     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
5665 f9cc6 fd1588        	ldy	_OSTCBCur
5666 f9cc9 e6e823        	ldab	35,y
5668 f9ccc 2708          	beq	L7333
5669 f9cce 04010f        	dbeq	b,L3433
5670 f9cd1 040108        	dbeq	b,L1433
5671 f9cd4 200a          	bra	L3433
5672 f9cd6               L7333:
5673                     ; 591         case OS_STAT_PEND_OK:
5673                     ; 592              *perr = OS_ERR_NONE;
5675 f9cd6 69f3000f      	clr	[OFST+8,s]
5676                     ; 593              break;
5678 f9cda 2017          	bra	L7643
5679 f9cdc               L1433:
5680                     ; 595         case OS_STAT_PEND_ABORT:
5680                     ; 596              *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted getting mutex        */
5682 f9cdc c60e          	ldab	#14
5683                     ; 597              break;
5685 f9cde 200c          	bra	LC006
5686 f9ce0               L3433:
5687                     ; 599         case OS_STAT_PEND_TO:
5687                     ; 600         default:
5687                     ; 601              OS_EventTaskRemove(OSTCBCur, pevent);
5689 f9ce0 ec87          	ldd	OFST+0,s
5690 f9ce2 3b            	pshd	
5691 f9ce3 b764          	tfr	y,d
5692 f9ce5 164737        	jsr	_OS_EventTaskRemove
5694 f9ce8 1b82          	leas	2,s
5695                     ; 602              *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get mutex within TO   */
5697 f9cea c60a          	ldab	#10
5698 f9cec               LC006:
5699 f9cec 6bf3000f      	stab	[OFST+8,s]
5700                     ; 603              break;
5702 f9cf0 fd1588        	ldy	_OSTCBCur
5703 f9cf3               L7643:
5704                     ; 605     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
5706 f9cf3 c7            	clrb	
5707 f9cf4 6be822        	stab	34,y
5708                     ; 606     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
5710 f9cf7 87            	clra	
5711 f9cf8 6ae823        	staa	35,y
5712                     ; 607     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
5714 f9cfb 6ce812        	std	18,y
5715                     ; 609     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
5717 f9cfe 6ce814        	std	20,y
5718                     ; 610     OSTCBCur->OSTCBEventMultiRdy = (OS_EVENT  *)0;
5720 f9d01 6ce816        	std	22,y
5721                     ; 612     OS_EXIT_CRITICAL();
5723 f9d04 e686          	ldab	OFST-1,s
5724 f9d06 164b54        	jsr	_OS_CPU_SR_Restore
5726                     ; 615 }
5730 f9d09 1b89          	leas	9,s
5731 f9d0b 3d            	rts	
5796                     ; 642 _NEAR INT8U  OSMutexPost (OS_EVENT *pevent)
5796                     ; 643 {
5797                     	switch	.text
5798 f9d0c               _OSMutexPost:
5800 f9d0c 3b            	pshd	
5801 f9d0d 1b9d          	leas	-3,s
5802       00000003      OFST:	set	3
5805                     ; 647     OS_CPU_SR  cpu_sr = 0u;
5807                     ; 651     if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
5809 f9d0f f6163c        	ldab	_OSIntNesting
5810 f9d12 2704          	beq	L7153
5811                     ; 652         return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
5813 f9d14 c605          	ldab	#5
5815 f9d16 2006          	bra	L63
5816 f9d18               L7153:
5817                     ; 655     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
5819 f9d18 ec83          	ldd	OFST+0,s
5820 f9d1a 2605          	bne	L1253
5821                     ; 656         return (OS_ERR_PEVENT_NULL);
5823 f9d1c c604          	ldab	#4
5825 f9d1e               L63:
5827 f9d1e 1b85          	leas	5,s
5828 f9d20 3d            	rts	
5829 f9d21               L1253:
5830                     ; 662     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
5833 f9d21 e6f30003      	ldab	[OFST+0,s]
5834 f9d25 c104          	cmpb	#4
5835 f9d27 2704          	beq	L3253
5836                     ; 664         return (OS_ERR_EVENT_TYPE);
5839 f9d29 c601          	ldab	#1
5841 f9d2b 20f1          	bra	L63
5842 f9d2d               L3253:
5843                     ; 666     OS_ENTER_CRITICAL();
5845 f9d2d 164b4f        	jsr	_OS_CPU_SR_Save
5847 f9d30 6b82          	stab	OFST-1,s
5848                     ; 667     pcp  = (INT8U)(pevent->OSEventCnt >> 8u);         /* Get priority ceiling priority of mutex        */
5850 f9d32 ed83          	ldy	OFST+0,s
5851 f9d34 180a4380      	movb	3,y,OFST-3,s
5852                     ; 668     prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
5854 f9d38 180a4481      	movb	4,y,OFST-2,s
5855                     ; 669     if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
5857 f9d3c fc1588        	ldd	_OSTCBCur
5858 f9d3f ac41          	cpd	1,y
5859 f9d41 270a          	beq	L5253
5860                     ; 670         OS_EXIT_CRITICAL();
5862 f9d43 e682          	ldab	OFST-1,s
5863 f9d45 87            	clra	
5864 f9d46 164b54        	jsr	_OS_CPU_SR_Restore
5866                     ; 672         return (OS_ERR_NOT_MUTEX_OWNER);
5869 f9d49 c664          	ldab	#100
5871 f9d4b 20d1          	bra	L63
5872 f9d4d               L5253:
5873                     ; 674     if (pcp != OS_PRIO_MUTEX_CEIL_DIS) {
5875 f9d4d e680          	ldab	OFST-3,s
5876 f9d4f 048124        	ibeq	b,L7253
5877                     ; 675         if (OSTCBCur->OSTCBPrio == pcp) {             /* Did we have to raise current task's priority? */
5879 f9d52 fd1588        	ldy	_OSTCBCur
5880 f9d55 e6e824        	ldab	36,y
5881 f9d58 e180          	cmpb	OFST-3,s
5882 f9d5a 260b          	bne	L1353
5883                     ; 677             OSMutex_RdyAtPrio(OSTCBCur, prio);        /* Restore the task's original priority          */
5886 f9d5c e681          	ldab	OFST-2,s
5887 f9d5e 87            	clra	
5888 f9d5f 3b            	pshd	
5889 f9d60 b764          	tfr	y,d
5890 f9d62 165e48        	jsr	L3462_OSMutex_RdyAtPrio
5892 f9d65 1b82          	leas	2,s
5893 f9d67               L1353:
5894                     ; 679         OSTCBPrioTbl[pcp] = OS_TCB_RESERVED;          /* Reserve table entry                           */
5896 f9d67 e680          	ldab	OFST-3,s
5897 f9d69 87            	clra	
5898 f9d6a 59            	lsld	
5899 f9d6b b746          	tfr	d,y
5900 f9d6d cc0001        	ldd	#1
5901 f9d70 6cea1502      	std	_OSTCBPrioTbl,y
5902 f9d74 ed83          	ldy	OFST+0,s
5903 f9d76               L7253:
5904                     ; 681     if (pevent->OSEventGrp != 0u) {                   /* Any task waiting for the mutex?               */
5906 f9d76 e645          	ldab	5,y
5907 f9d78 274f          	beq	L3353
5908                     ; 683         prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
5910 f9d7a 87            	clra	
5911 f9d7b c7            	clrb	
5912 f9d7c 3b            	pshd	
5913 f9d7d c610          	ldab	#16
5914 f9d7f 3b            	pshd	
5915 f9d80 c7            	clrb	
5916 f9d81 3b            	pshd	
5917 f9d82 ec89          	ldd	OFST+6,s
5918 f9d84 1645fc        	jsr	_OS_EventTaskRdy
5920 f9d87 1b86          	leas	6,s
5921 f9d89 6b81          	stab	OFST-2,s
5922                     ; 684         pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
5924 f9d8b ed83          	ldy	OFST+0,s
5925 f9d8d 87            	clra	
5926 f9d8e 6a44          	staa	4,y
5927                     ; 685         pevent->OSEventCnt |= (INT16U)prio;
5929 f9d90 ea44          	orab	4,y
5930 f9d92 aa43          	oraa	3,y
5931 f9d94 6c43          	std	3,y
5932                     ; 686         pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
5934 f9d96 e681          	ldab	OFST-2,s
5935 f9d98 87            	clra	
5936 f9d99 59            	lsld	
5937 f9d9a b746          	tfr	d,y
5938 f9d9c ecea1502      	ldd	_OSTCBPrioTbl,y
5939 f9da0 ee83          	ldx	OFST+0,s
5940 f9da2 6c01          	std	1,x
5941                     ; 687         if ((pcp  != OS_PRIO_MUTEX_CEIL_DIS) &&
5941                     ; 688             (prio <= pcp)) {                          /*      PCP 'must' have a SMALLER prio ...       */
5943 f9da4 e680          	ldab	OFST-3,s
5944 f9da6 048113        	ibeq	b,L5353
5946 f9da9 e681          	ldab	OFST-2,s
5947 f9dab e180          	cmpb	OFST-3,s
5948 f9dad 220d          	bhi	L5353
5949                     ; 689             OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
5951 f9daf e682          	ldab	OFST-1,s
5952 f9db1 87            	clra	
5953 f9db2 164b54        	jsr	_OS_CPU_SR_Restore
5955                     ; 690             OS_Sched();                               /*      Find highest priority task ready to run  */
5957 f9db5 164933        	jsr	_OS_Sched
5959                     ; 692             return (OS_ERR_PCP_LOWER);
5962 f9db8 c678          	ldab	#120
5964 f9dba 200a          	bra	L04
5965 f9dbc               L5353:
5966                     ; 694             OS_EXIT_CRITICAL();
5968 f9dbc e682          	ldab	OFST-1,s
5969 f9dbe 87            	clra	
5970 f9dbf 164b54        	jsr	_OS_CPU_SR_Restore
5972                     ; 695             OS_Sched();                               /*      Find highest priority task ready to run  */
5974 f9dc2 164933        	jsr	_OS_Sched
5976                     ; 697             return (OS_ERR_NONE);
5979 f9dc5               LC007:
5980 f9dc5 c7            	clrb	
5982 f9dc6               L04:
5984 f9dc6 1b85          	leas	5,s
5985 f9dc8 3d            	rts	
5986 f9dc9               L3353:
5987                     ; 700     pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
5989 f9dc9 0c44ff        	bset	4,y,255
5990                     ; 701     pevent->OSEventPtr  = (void *)0;
5992 f9dcc 87            	clra	
5993 f9dcd 6c41          	std	1,y
5994                     ; 702     OS_EXIT_CRITICAL();
5996 f9dcf e682          	ldab	OFST-1,s
5997 f9dd1 164b54        	jsr	_OS_CPU_SR_Restore
5999                     ; 704     return (OS_ERR_NONE);
6003 f9dd4 20ef          	bra	LC007
6133                     ; 727 _NEAR INT8U  OSMutexQuery (OS_EVENT       *pevent,
6133                     ; 728                           OS_MUTEX_DATA  *p_mutex_data)
6133                     ; 729 {
6134                     	switch	.text
6135 f9dd6               _OSMutexQuery:
6137 f9dd6 3b            	pshd	
6138 f9dd7 1b9a          	leas	-6,s
6139       00000006      OFST:	set	6
6142                     ; 734     OS_CPU_SR   cpu_sr = 0u;
6144                     ; 739     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
6146 f9dd9 f6163c        	ldab	_OSIntNesting
6147 f9ddc 2704          	beq	L3263
6148                     ; 740         return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
6150 f9dde c606          	ldab	#6
6152 f9de0 2006          	bra	L44
6153 f9de2               L3263:
6154                     ; 743     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
6156 f9de2 ec86          	ldd	OFST+0,s
6157 f9de4 2605          	bne	L5263
6158                     ; 744         return (OS_ERR_PEVENT_NULL);
6160 f9de6 c604          	ldab	#4
6162 f9de8               L44:
6164 f9de8 1b88          	leas	8,s
6165 f9dea 3d            	rts	
6166 f9deb               L5263:
6167                     ; 746     if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
6169 f9deb ec8a          	ldd	OFST+4,s
6170 f9ded 2604          	bne	L7263
6171                     ; 747         return (OS_ERR_PDATA_NULL);
6173 f9def c609          	ldab	#9
6175 f9df1 20f5          	bra	L44
6176 f9df3               L7263:
6177                     ; 750     if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
6179 f9df3 e6f30006      	ldab	[OFST+0,s]
6180 f9df7 c104          	cmpb	#4
6181 f9df9 2704          	beq	L1363
6182                     ; 751         return (OS_ERR_EVENT_TYPE);
6184 f9dfb c601          	ldab	#1
6186 f9dfd 20e9          	bra	L44
6187 f9dff               L1363:
6188                     ; 753     OS_ENTER_CRITICAL();
6190 f9dff 164b4f        	jsr	_OS_CPU_SR_Save
6192 f9e02 6b85          	stab	OFST-1,s
6193                     ; 754     p_mutex_data->OSMutexPCP  = (INT8U)(pevent->OSEventCnt >> 8u);
6195 f9e04 ee86          	ldx	OFST+0,s
6196 f9e06 ed8a          	ldy	OFST+4,s
6197 f9e08 180a034b      	movb	3,x,11,y
6198                     ; 755     p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
6200 f9e0c e604          	ldab	4,x
6201 f9e0e 6b4a          	stab	10,y
6202                     ; 756     if (p_mutex_data->OSOwnerPrio == 0xFFu) {
6204 f9e10 04a106        	ibne	b,L3363
6205                     ; 757         p_mutex_data->OSValue = OS_TRUE;
6207 f9e13 c601          	ldab	#1
6208 f9e15 6b49          	stab	9,y
6210 f9e17 2002          	bra	L5363
6211 f9e19               L3363:
6212                     ; 759         p_mutex_data->OSValue = OS_FALSE;
6214 f9e19 6949          	clr	9,y
6215 f9e1b               L5363:
6216                     ; 761     p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
6218 f9e1b 180a0548      	movb	5,x,8,y
6219                     ; 762     psrc                      = &pevent->OSEventTbl[0];
6221 f9e1f ed86          	ldy	OFST+0,s
6222 f9e21 1946          	leay	6,y
6223 f9e23 6d81          	sty	OFST-5,s
6224                     ; 763     pdest                     = &p_mutex_data->OSEventTbl[0];
6226 f9e25 18028a83      	movw	OFST+4,s,OFST-3,s
6227                     ; 764     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
6229 f9e29 6980          	clr	OFST-6,s
6230 f9e2b ee81          	ldx	OFST-5,s
6231 f9e2d ed83          	ldy	OFST-3,s
6232 f9e2f               L7363:
6233                     ; 765         *pdest++ = *psrc++;
6235 f9e2f 180a3070      	movb	1,x+,1,y+
6236                     ; 764     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
6238 f9e33 6280          	inc	OFST-6,s
6241 f9e35 e680          	ldab	OFST-6,s
6242 f9e37 c108          	cmpb	#8
6243 f9e39 25f4          	blo	L7363
6244 f9e3b 6e81          	stx	OFST-5,s
6245 f9e3d 6d83          	sty	OFST-3,s
6246                     ; 767     OS_EXIT_CRITICAL();
6248 f9e3f e685          	ldab	OFST-1,s
6249 f9e41 87            	clra	
6250 f9e42 164b54        	jsr	_OS_CPU_SR_Restore
6252                     ; 768     return (OS_ERR_NONE);
6254 f9e45 c7            	clrb	
6256 f9e46 20a0          	bra	L44
6310                     ; 787 static  void  OSMutex_RdyAtPrio (OS_TCB  *ptcb,
6310                     ; 788                                  INT8U    prio)
6310                     ; 789 {
6311                     	switch	.text
6312 f9e48               L3462_OSMutex_RdyAtPrio:
6314 f9e48 3b            	pshd	
6315 f9e49 37            	pshb	
6316       00000001      OFST:	set	1
6319                     ; 793     y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pcp'    */
6321 f9e4a b746          	tfr	d,y
6322 f9e4c e6e826        	ldab	38,y
6323 f9e4f 6b80          	stab	OFST-1,s
6324                     ; 794     OSRdyTbl[y] &= (OS_PRIO)~ptcb->OSTCBBitX;
6326 f9e51 b796          	exg	b,y
6327 f9e53 ee81          	ldx	OFST+0,s
6328 f9e55 e6e027        	ldab	39,x
6329 f9e58 51            	comb	
6330 f9e59 e4ea1630      	andb	_OSRdyTbl,y
6331 f9e5d 6bea1630      	stab	_OSRdyTbl,y
6332                     ; 796     if (OSRdyTbl[y] == 0u) {
6335 f9e61 260c          	bne	L1763
6336                     ; 797         OSRdyGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
6338 f9e63 b756          	tfr	x,y
6339 f9e65 e6e828        	ldab	40,y
6340 f9e68 51            	comb	
6341 f9e69 f41638        	andb	_OSRdyGrp
6342 f9e6c 7b1638        	stab	_OSRdyGrp
6343 f9e6f               L1763:
6344                     ; 799     ptcb->OSTCBPrio         = prio;
6346 f9e6f e686          	ldab	OFST+5,s
6347 f9e71 b756          	tfr	x,y
6348 f9e73 6be824        	stab	36,y
6349                     ; 800     OSPrioCur               = prio;                        /* The current task is now at this priority */
6351 f9e76 7b163a        	stab	_OSPrioCur
6352                     ; 802     ptcb->OSTCBY            = (INT8U)((INT8U)(prio >> 3u) & 0x07u);
6354 f9e79 c438          	andb	#56
6355 f9e7b 54            	lsrb	
6356 f9e7c 54            	lsrb	
6357 f9e7d 54            	lsrb	
6358 f9e7e 6be826        	stab	38,y
6359                     ; 803     ptcb->OSTCBX            = (INT8U)(prio & 0x07u);
6361 f9e81 e686          	ldab	OFST+5,s
6362 f9e83 c407          	andb	#7
6363 f9e85 6be825        	stab	37,y
6364                     ; 808     ptcb->OSTCBBitY         = (OS_PRIO)(1uL << ptcb->OSTCBY);
6366 f9e88 c601          	ldab	#1
6367 f9e8a a6e826        	ldaa	38,y
6368 f9e8d 2704          	beq	L05
6369 f9e8f               L25:
6370 f9e8f 58            	lslb	
6371 f9e90 0430fc        	dbne	a,L25
6372 f9e93               L05:
6373 f9e93 6be828        	stab	40,y
6374                     ; 809     ptcb->OSTCBBitX         = (OS_PRIO)(1uL << ptcb->OSTCBX);
6376 f9e96 c601          	ldab	#1
6377 f9e98 a6e825        	ldaa	37,y
6378 f9e9b 2704          	beq	L45
6379 f9e9d               L65:
6380 f9e9d 58            	lslb	
6381 f9e9e 0430fc        	dbne	a,L65
6382 f9ea1               L45:
6383 f9ea1 6be827        	stab	39,y
6384                     ; 810     OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
6386 f9ea4 e6e828        	ldab	40,y
6387 f9ea7 fa1638        	orab	_OSRdyGrp
6388 f9eaa 7b1638        	stab	_OSRdyGrp
6389                     ; 811     OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
6391 f9ead e6e826        	ldab	38,y
6392 f9eb0 87            	clra	
6393 f9eb1 b746          	tfr	d,y
6394 f9eb3 e6e027        	ldab	39,x
6395 f9eb6 eaea1630      	orab	_OSRdyTbl,y
6396 f9eba 6bea1630      	stab	_OSRdyTbl,y
6397                     ; 812     OSTCBPrioTbl[prio]      = ptcb;
6399 f9ebe e686          	ldab	OFST+5,s
6400 f9ec0 59            	lsld	
6401 f9ec1 b746          	tfr	d,y
6402 f9ec3 6eea1502      	stx	_OSTCBPrioTbl,y
6403                     ; 814 }
6407 f9ec7 1b83          	leas	3,s
6408 f9ec9 3d            	rts	
6420                     	xref	_OS_Sched
6421                     	xref	_OS_EventWaitListInit
6422                     	xref	_OS_EventTaskRemove
6423                     	xref	_OS_EventTaskWait
6424                     	xref	_OS_EventTaskRdy
6425                     	xdef	_OSMutexQuery
6426                     	xdef	_OSMutexPost
6427                     	xdef	_OSMutexPend
6428                     	xdef	_OSMutexDel
6429                     	xdef	_OSMutexCreate
6430                     	xdef	_OSMutexAccept
6431                     	xref	_OSTCBPrioTbl
6432                     	xref	_OSTCBCur
6433                     	xref	_OSRdyTbl
6434                     	xref	_OSRdyGrp
6435                     	xref	_OSPrioCur
6436                     	xref	_OSLockNesting
6437                     	xref	_OSIntNesting
6438                     	xref	_OSEventFreeList
6439                     	xref	_OS_CPU_SR_Restore
6440                     	xref	_OS_CPU_SR_Save
6441                     .const:	section	.data
6442 fb73d               L5103:
6443 fb73d 3f00          	dc.b	"?",0
6464                     	end
