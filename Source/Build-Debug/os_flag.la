   1                     ; C Compiler for 68HCS12 [COSMIC Software]
   2                     ; Parser V4.11.9 - 08 Feb 2017
   3                     ; Generator V4.8.12 - 22 Feb 2017
   4                     ; Optimizer V4.7.11 - 22 Feb 2017
4118                     ; 101 _NEAR OS_FLAGS  OSFlagAccept (OS_FLAG_GRP  *pgrp,
4118                     ; 102                              OS_FLAGS      flags,
4118                     ; 103                              INT8U         wait_type,
4118                     ; 104                              INT8U        *perr)
4118                     ; 105 {
4119                     	switch	.text
4120 f8c2a               _OSFlagAccept:
4122 f8c2a 3b            	pshd	
4123 f8c2b 1b9c          	leas	-4,s
4124       00000004      OFST:	set	4
4127                     ; 110     OS_CPU_SR     cpu_sr = 0u;
4129                     ; 123     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
4131 f8c2d 046404        	tbne	d,L7472
4132                     ; 124         *perr = OS_ERR_FLAG_INVALID_PGRP;
4134 f8c30 c66e          	ldab	#110
4135                     ; 125         return ((OS_FLAGS)0);
4138 f8c32 200a          	bra	L6
4139 f8c34               L7472:
4140                     ; 128     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
4142 f8c34 e6f30004      	ldab	[OFST+0,s]
4143 f8c38 c105          	cmpb	#5
4144 f8c3a 270b          	beq	L1572
4145                     ; 129         *perr = OS_ERR_EVENT_TYPE;
4147 f8c3c c601          	ldab	#1
4148                     ; 130         return ((OS_FLAGS)0);
4151 f8c3e               L6:
4152 f8c3e 6bf3000c      	stab	[OFST+8,s]
4153 f8c42 87            	clra	
4154 f8c43 c7            	clrb	
4156 f8c44 1b86          	leas	6,s
4157 f8c46 3d            	rts	
4158 f8c47               L1572:
4159                     ; 132     result = (INT8U)(wait_type & OS_FLAG_CONSUME);
4161 f8c47 e68b          	ldab	OFST+7,s
4162 f8c49 c480          	andb	#128
4163 f8c4b 6b82          	stab	OFST-2,s
4164                     ; 133     if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
4166 f8c4d 2709          	beq	L3572
4167                     ; 134         wait_type &= ~OS_FLAG_CONSUME;
4169 f8c4f 0d8b80        	bclr	OFST+7,s,128
4170                     ; 135         consume    = OS_TRUE;
4172 f8c52 c601          	ldab	#1
4173 f8c54 6b82          	stab	OFST-2,s
4175 f8c56 2002          	bra	L5572
4176 f8c58               L3572:
4177                     ; 137         consume    = OS_FALSE;
4179 f8c58 6982          	clr	OFST-2,s
4180 f8c5a               L5572:
4181                     ; 140     *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
4183 f8c5a 69f3000c      	clr	[OFST+8,s]
4184                     ; 141     OS_ENTER_CRITICAL();
4186 f8c5e 164b4f        	jsr	_OS_CPU_SR_Save
4188 f8c61 6b83          	stab	OFST-1,s
4189                     ; 142     switch (wait_type) {
4191 f8c63 e68b          	ldab	OFST+7,s
4193 f8c65 2748          	beq	L3562
4194 f8c67 53            	decb	
4195 f8c68 2762          	beq	L5562
4196 f8c6a 040115        	dbeq	b,L7462
4197 f8c6d 040131        	dbeq	b,L1562
4198                     ; 193         default:
4198                     ; 194              OS_EXIT_CRITICAL();
4200 f8c70 e683          	ldab	OFST-1,s
4201 f8c72 87            	clra	
4202 f8c73 164b54        	jsr	_OS_CPU_SR_Restore
4204                     ; 195              flags_rdy = (OS_FLAGS)0;
4206 f8c76 87            	clra	
4207 f8c77 c7            	clrb	
4208 f8c78 6c80          	std	OFST-4,s
4209                     ; 196              *perr     = OS_ERR_FLAG_WAIT_TYPE;
4211 f8c7a c66f          	ldab	#111
4212 f8c7c 6bf3000c      	stab	[OFST+8,s]
4213                     ; 197              break;
4215 f8c80 206b          	bra	L1672
4216 f8c82               L7462:
4217                     ; 143         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
4217                     ; 144              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
4219 f8c82 ed84          	ldy	OFST+0,s
4220 f8c84 ec43          	ldd	3,y
4221 f8c86 e489          	andb	OFST+5,s
4222 f8c88 a488          	anda	OFST+4,s
4223 f8c8a 6c80          	std	OFST-4,s
4224                     ; 145              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
4226 f8c8c ac88          	cpd	OFST+4,s
4227 f8c8e 2651          	bne	L5003
4228                     ; 146                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
4230                     ; 147                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we wanted  */
4232 f8c90               LC004:
4233 f8c90 e682          	ldab	OFST-2,s
4234 f8c92 53            	decb	
4235 f8c93 2652          	bne	L1103
4236 f8c95 ec80          	ldd	OFST-4,s
4237 f8c97 51            	comb	
4238 f8c98 41            	coma	
4239 f8c99 e444          	andb	4,y
4240 f8c9b a443          	anda	3,y
4241 f8c9d               LC003:
4242 f8c9d 6c43          	std	3,y
4243 f8c9f 2046          	bra	L1103
4244                     ; 150                  *perr = OS_ERR_FLAG_NOT_RDY;
4246                     ; 152              OS_EXIT_CRITICAL();
4249                     ; 153              break;
4251 f8ca1               L1562:
4252                     ; 155         case OS_FLAG_WAIT_SET_ANY:
4252                     ; 156              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
4254 f8ca1 ed84          	ldy	OFST+0,s
4255 f8ca3 ec43          	ldd	3,y
4256 f8ca5 e489          	andb	OFST+5,s
4257 f8ca7 a488          	anda	OFST+4,s
4258 f8ca9 6c80          	std	OFST-4,s
4259                     ; 157              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
4261 f8cab 2734          	beq	L5003
4262                     ; 158                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
4264                     ; 159                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;     /* Clear ONLY the flags we got     */
4266 f8cad 20e1          	bra	LC004
4267                     ; 162                  *perr = OS_ERR_FLAG_NOT_RDY;
4269                     ; 164              OS_EXIT_CRITICAL();
4272                     ; 165              break;
4274 f8caf               L3562:
4275                     ; 168         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
4275                     ; 169              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
4277 f8caf ed84          	ldy	OFST+0,s
4278 f8cb1 ec43          	ldd	3,y
4279 f8cb3 51            	comb	
4280 f8cb4 41            	coma	
4281 f8cb5 e489          	andb	OFST+5,s
4282 f8cb7 a488          	anda	OFST+4,s
4283 f8cb9 6c80          	std	OFST-4,s
4284                     ; 170              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
4286 f8cbb ac88          	cpd	OFST+4,s
4287 f8cbd 2622          	bne	L5003
4288                     ; 171                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
4290 f8cbf e682          	ldab	OFST-2,s
4291 f8cc1 53            	decb	
4292 f8cc2 2623          	bne	L1103
4293                     ; 172                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
4295 f8cc4               LC005:
4296 f8cc4 ec43          	ldd	3,y
4297 f8cc6 ea81          	orab	OFST-3,s
4298 f8cc8 aa80          	oraa	OFST-4,s
4299 f8cca 20d1          	bra	LC003
4300                     ; 175                  *perr = OS_ERR_FLAG_NOT_RDY;
4302                     ; 177              OS_EXIT_CRITICAL();
4305                     ; 178              break;
4307 f8ccc               L5562:
4308                     ; 180         case OS_FLAG_WAIT_CLR_ANY:
4308                     ; 181              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
4310 f8ccc ed84          	ldy	OFST+0,s
4311 f8cce ec43          	ldd	3,y
4312 f8cd0 51            	comb	
4313 f8cd1 41            	coma	
4314 f8cd2 e489          	andb	OFST+5,s
4315 f8cd4 a488          	anda	OFST+4,s
4316 f8cd6 6c80          	std	OFST-4,s
4317                     ; 182              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
4319 f8cd8 2707          	beq	L5003
4320                     ; 183                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
4322 f8cda e682          	ldab	OFST-2,s
4323 f8cdc 042108        	dbne	b,L1103
4324                     ; 184                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
4326 f8cdf 20e3          	bra	LC005
4327 f8ce1               L5003:
4328                     ; 187                  *perr = OS_ERR_FLAG_NOT_RDY;
4330 f8ce1 c670          	ldab	#112
4331 f8ce3 6bf3000c      	stab	[OFST+8,s]
4332 f8ce7               L1103:
4333                     ; 189              OS_EXIT_CRITICAL();
4335 f8ce7 e683          	ldab	OFST-1,s
4336 f8ce9 87            	clra	
4337 f8cea 164b54        	jsr	_OS_CPU_SR_Restore
4339                     ; 190              break;
4341 f8ced               L1672:
4342                     ; 199     return (flags_rdy);
4344 f8ced ec80          	ldd	OFST-4,s
4347 f8cef 1b86          	leas	6,s
4348 f8cf1 3d            	rts	
4415                     ; 226 _NEAR OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS  flags,
4415                     ; 227                                  INT8U    *perr)
4415                     ; 228 {
4416                     	switch	.text
4417 f8cf2               _OSFlagCreate:
4419 f8cf2 3b            	pshd	
4420 f8cf3 1b9d          	leas	-3,s
4421       00000003      OFST:	set	3
4424                     ; 231     OS_CPU_SR    cpu_sr = 0u;
4426                     ; 251     if (OSIntNesting > 0u) {                        /* See if called from ISR ...                      */
4428 f8cf5 f6163c        	ldab	_OSIntNesting
4429 f8cf8 270a          	beq	L5403
4430                     ; 252         *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
4432 f8cfa c610          	ldab	#16
4433 f8cfc 6bf30007      	stab	[OFST+4,s]
4434                     ; 253         return ((OS_FLAG_GRP *)0);
4436 f8d00 87            	clra	
4437 f8d01 c7            	clrb	
4439 f8d02 203c          	bra	L21
4440 f8d04               L5403:
4441                     ; 255     OS_ENTER_CRITICAL();
4443 f8d04 164b4f        	jsr	_OS_CPU_SR_Save
4445 f8d07 6b82          	stab	OFST-1,s
4446                     ; 256     pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
4448 f8d09 fd163d        	ldy	_OSFlagFreeList
4449 f8d0c 6d80          	sty	OFST-3,s
4450                     ; 257     if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
4452 f8d0e ee80          	ldx	OFST-3,s
4453 f8d10 2722          	beq	L7403
4454                     ; 259         OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
4456 f8d12 180541163d    	movw	1,y,_OSFlagFreeList
4457                     ; 260         pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
4459 f8d17 c605          	ldab	#5
4460 f8d19 6b00          	stab	0,x
4461                     ; 261         pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
4463 f8d1b 18028343      	movw	OFST+0,s,3,y
4464                     ; 262         pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
4466 f8d1f 87            	clra	
4467 f8d20 c7            	clrb	
4468 f8d21 6c41          	std	1,y
4469                     ; 264         pgrp->OSFlagName     = (INT8U *)(void *)"?";
4471 f8d23 cc7733        	ldd	#L1503
4472 f8d26 6c45          	std	5,y
4473                     ; 267         OS_EXIT_CRITICAL();
4476 f8d28 e682          	ldab	OFST-1,s
4477 f8d2a 87            	clra	
4478 f8d2b 164b54        	jsr	_OS_CPU_SR_Restore
4480                     ; 268         *perr                = OS_ERR_NONE;
4482 f8d2e 69f30007      	clr	[OFST+4,s]
4484 f8d32 200a          	bra	L3503
4485 f8d34               L7403:
4486                     ; 270         OS_EXIT_CRITICAL();
4488 f8d34 87            	clra	
4489 f8d35 164b54        	jsr	_OS_CPU_SR_Restore
4491                     ; 271         *perr                = OS_ERR_FLAG_GRP_DEPLETED;
4493 f8d38 c672          	ldab	#114
4494 f8d3a 6bf30007      	stab	[OFST+4,s]
4495 f8d3e               L3503:
4496                     ; 273     return (pgrp);                                  /* Return pointer to event flag group              */
4498 f8d3e ec80          	ldd	OFST-3,s
4500 f8d40               L21:
4502 f8d40 1b85          	leas	5,s
4503 f8d42 3d            	rts	
4664                     ; 318 _NEAR OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP  *pgrp,
4664                     ; 319                               INT8U         opt,
4664                     ; 320                               INT8U        *perr)
4664                     ; 321 {
4665                     	switch	.text
4666 f8d43               _OSFlagDel:
4668 f8d43 3b            	pshd	
4669 f8d44 1b9c          	leas	-4,s
4670       00000004      OFST:	set	4
4673                     ; 326     OS_CPU_SR     cpu_sr = 0u;
4675                     ; 346     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
4677 f8d46 046404        	tbne	d,L3613
4678                     ; 347         *perr = OS_ERR_FLAG_INVALID_PGRP;
4680 f8d49 c66e          	ldab	#110
4681                     ; 348         return (pgrp);
4684 f8d4b 2007          	bra	L61
4685 f8d4d               L3613:
4686                     ; 354     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
4689 f8d4d f6163c        	ldab	_OSIntNesting
4690 f8d50 270b          	beq	L5613
4691                     ; 355         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
4693 f8d52 c60f          	ldab	#15
4694                     ; 357         return (pgrp);
4698 f8d54               L61:
4699 f8d54 6bf3000a      	stab	[OFST+6,s]
4700 f8d58 ec84          	ldd	OFST+0,s
4702 f8d5a 1b86          	leas	6,s
4703 f8d5c 3d            	rts	
4704 f8d5d               L5613:
4705                     ; 359     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
4707 f8d5d e6f30004      	ldab	[OFST+0,s]
4708 f8d61 c105          	cmpb	#5
4709 f8d63 2704          	beq	L7613
4710                     ; 360         *perr = OS_ERR_EVENT_TYPE;
4712 f8d65 c601          	ldab	#1
4713                     ; 362         return (pgrp);
4717 f8d67 20eb          	bra	L61
4718 f8d69               L7613:
4719                     ; 364     OS_ENTER_CRITICAL();
4721 f8d69 164b4f        	jsr	_OS_CPU_SR_Save
4723 f8d6c 6b82          	stab	OFST-2,s
4724                     ; 365     if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
4726 f8d6e ed84          	ldy	OFST+0,s
4727 f8d70 ec41          	ldd	1,y
4728 f8d72 2706          	beq	L1713
4729                     ; 366         tasks_waiting = OS_TRUE;                           /* Yes                                      */
4731 f8d74 c601          	ldab	#1
4732 f8d76 6b83          	stab	OFST-1,s
4734 f8d78 2002          	bra	L3713
4735 f8d7a               L1713:
4736                     ; 368         tasks_waiting = OS_FALSE;                          /* No                                       */
4738 f8d7a 6983          	clr	OFST-1,s
4739 f8d7c               L3713:
4740                     ; 370     switch (opt) {
4742 f8d7c e689          	ldab	OFST+5,s
4744 f8d7e 270d          	beq	L5503
4745 f8d80 040142        	dbeq	b,L7503
4746                     ; 411         default:
4746                     ; 412              OS_EXIT_CRITICAL();
4748 f8d83 e682          	ldab	OFST-2,s
4749 f8d85 87            	clra	
4750 f8d86 164b54        	jsr	_OS_CPU_SR_Restore
4752                     ; 413              *perr                = OS_ERR_INVALID_OPT;
4754 f8d89 c607          	ldab	#7
4755                     ; 414              pgrp_return          = pgrp;
4757                     ; 415              break;
4759 f8d8b 202e          	bra	LC007
4760 f8d8d               L5503:
4761                     ; 371         case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
4761                     ; 372              if (tasks_waiting == OS_FALSE) {
4763 f8d8d e683          	ldab	OFST-1,s
4764 f8d8f 2622          	bne	L1023
4765                     ; 374                  pgrp->OSFlagName     = (INT8U *)(void *)"?";
4767 f8d91 cc7733        	ldd	#L1503
4768 f8d94 6c45          	std	5,y
4769                     ; 376                  pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
4771 f8d96 87            	clra	
4772 f8d97 6a40          	staa	0,y
4773                     ; 377                  pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
4775 f8d99 180141163d    	movw	_OSFlagFreeList,1,y
4776                     ; 378                  pgrp->OSFlagFlags    = (OS_FLAGS)0;
4778 f8d9e c7            	clrb	
4779 f8d9f 6c43          	std	3,y
4780                     ; 379                  OSFlagFreeList       = pgrp;
4782 f8da1 180584163d    	movw	OFST+0,s,_OSFlagFreeList
4783                     ; 380                  OS_EXIT_CRITICAL();
4785 f8da6 e682          	ldab	OFST-2,s
4786 f8da8 164b54        	jsr	_OS_CPU_SR_Restore
4788                     ; 381                  *perr                = OS_ERR_NONE;
4790 f8dab 87            	clra	
4791 f8dac 6af3000a      	staa	[OFST+6,s]
4792                     ; 382                  pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
4794 f8db0 c7            	clrb	
4796 f8db1 200e          	bra	LC006
4797 f8db3               L1023:
4798                     ; 384                  OS_EXIT_CRITICAL();
4800 f8db3 e682          	ldab	OFST-2,s
4801 f8db5 87            	clra	
4802 f8db6 164b54        	jsr	_OS_CPU_SR_Restore
4804                     ; 385                  *perr                = OS_ERR_TASK_WAITING;
4806 f8db9 c649          	ldab	#73
4807                     ; 386                  pgrp_return          = pgrp;
4809 f8dbb               LC007:
4810 f8dbb 6bf3000a      	stab	[OFST+6,s]
4811 f8dbf ec84          	ldd	OFST+0,s
4812 f8dc1               LC006:
4813 f8dc1 6c80          	std	OFST-4,s
4814 f8dc3 2041          	bra	L7713
4815 f8dc5               L7503:
4816                     ; 390         case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
4816                     ; 391              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
4818 f8dc5 ec41          	ldd	1,y
4820 f8dc7 2011          	bra	L1123
4821 f8dc9               L5023:
4822                     ; 393                  (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0, OS_STAT_PEND_ABORT);
4824 f8dc9 cc0002        	ldd	#2
4825 f8dcc 3b            	pshd	
4826 f8dcd c7            	clrb	
4827 f8dce 3b            	pshd	
4828 f8dcf ec84          	ldd	OFST+0,s
4829 f8dd1 16523b        	jsr	L5462_OS_FlagTaskRdy
4831 f8dd4 1b84          	leas	4,s
4832                     ; 394                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
4834 f8dd6 ecf30000      	ldd	[OFST-4,s]
4835 f8dda               L1123:
4836 f8dda 6c80          	std	OFST-4,s
4837                     ; 392              while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
4839 f8ddc 26eb          	bne	L5023
4840                     ; 397              pgrp->OSFlagName     = (INT8U *)(void *)"?";
4842 f8dde cc7733        	ldd	#L1503
4843 f8de1 ed84          	ldy	OFST+0,s
4844 f8de3 6c45          	std	5,y
4845                     ; 399              pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
4847 f8de5 87            	clra	
4848 f8de6 6a40          	staa	0,y
4849                     ; 400              pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
4851 f8de8 180141163d    	movw	_OSFlagFreeList,1,y
4852                     ; 401              pgrp->OSFlagFlags    = (OS_FLAGS)0;
4854 f8ded c7            	clrb	
4855 f8dee 6c43          	std	3,y
4856                     ; 402              OSFlagFreeList       = pgrp;
4858 f8df0 7d163d        	sty	_OSFlagFreeList
4859                     ; 403              OS_EXIT_CRITICAL();
4861 f8df3 e682          	ldab	OFST-2,s
4862 f8df5 164b54        	jsr	_OS_CPU_SR_Restore
4864                     ; 404              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
4866 f8df8 e683          	ldab	OFST-1,s
4867 f8dfa 042103        	dbne	b,L5123
4868                     ; 405                  OS_Sched();                               /* Find highest priority task ready to run  */
4870 f8dfd 164933        	jsr	_OS_Sched
4872 f8e00               L5123:
4873                     ; 407              *perr = OS_ERR_NONE;
4875 f8e00 87            	clra	
4876 f8e01 6af3000a      	staa	[OFST+6,s]
4877                     ; 408              pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
4879 f8e05 c7            	clrb	
4880                     ; 409              break;
4882 f8e06               L7713:
4883                     ; 420     return (pgrp_return);
4888 f8e06 1b86          	leas	6,s
4889 f8e08 3d            	rts	
4964                     ; 449 _NEAR INT8U  OSFlagNameGet (OS_FLAG_GRP   *pgrp,
4964                     ; 450                            INT8U        **pname,
4964                     ; 451                            INT8U         *perr)
4964                     ; 452 {
4965                     	switch	.text
4966 f8e09               _OSFlagNameGet:
4968 f8e09 3b            	pshd	
4969       00000002      OFST:	set	2
4972                     ; 455     OS_CPU_SR  cpu_sr = 0u;
4974                     ; 468     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
4976 f8e0a 6cae          	std	2,-s
4977 f8e0c 2604          	bne	L3523
4978                     ; 469         *perr = OS_ERR_FLAG_INVALID_PGRP;
4980 f8e0e c66e          	ldab	#110
4981                     ; 470         return (0u);
4984 f8e10 2006          	bra	LC008
4985 f8e12               L3523:
4986                     ; 472     if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
4988 f8e12 ec86          	ldd	OFST+4,s
4989 f8e14 260a          	bne	L5523
4990                     ; 473         *perr = OS_ERR_PNAME_NULL;
4992 f8e16 c60c          	ldab	#12
4993                     ; 474         return (0u);
4995 f8e18               LC008:
4996 f8e18 6bf30008      	stab	[OFST+6,s]
4997 f8e1c c7            	clrb	
4999 f8e1d               L22:
5001 f8e1d 1b84          	leas	4,s
5002 f8e1f 3d            	rts	
5003 f8e20               L5523:
5004                     ; 477     if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
5006 f8e20 f6163c        	ldab	_OSIntNesting
5007 f8e23 2704          	beq	L7523
5008                     ; 478         *perr = OS_ERR_NAME_GET_ISR;
5010 f8e25 c611          	ldab	#17
5011                     ; 479         return (0u);
5014 f8e27 20ef          	bra	LC008
5015 f8e29               L7523:
5016                     ; 481     OS_ENTER_CRITICAL();
5018 f8e29 164b4f        	jsr	_OS_CPU_SR_Save
5020 f8e2c 6b80          	stab	OFST-2,s
5021                     ; 482     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
5023 f8e2e ed82          	ldy	OFST+0,s
5024 f8e30 e640          	ldab	0,y
5025 f8e32 c105          	cmpb	#5
5026 f8e34 270a          	beq	L1623
5027                     ; 483         OS_EXIT_CRITICAL();
5029 f8e36 e680          	ldab	OFST-2,s
5030 f8e38 87            	clra	
5031 f8e39 164b54        	jsr	_OS_CPU_SR_Restore
5033                     ; 484         *perr = OS_ERR_EVENT_TYPE;
5035 f8e3c c601          	ldab	#1
5036                     ; 485         return (0u);
5039 f8e3e 20d8          	bra	LC008
5040 f8e40               L1623:
5041                     ; 487     *pname = pgrp->OSFlagName;
5043 f8e40 ec45          	ldd	5,y
5044 f8e42 ee86          	ldx	OFST+4,s
5045 f8e44 6c00          	std	0,x
5046                     ; 488     len    = OS_StrLen(*pname);
5048 f8e46 1649af        	jsr	_OS_StrLen
5050 f8e49 6b81          	stab	OFST-1,s
5051                     ; 489     OS_EXIT_CRITICAL();
5053 f8e4b e680          	ldab	OFST-2,s
5054 f8e4d 87            	clra	
5055 f8e4e 164b54        	jsr	_OS_CPU_SR_Restore
5057                     ; 490     *perr  = OS_ERR_NONE;
5059 f8e51 69f30008      	clr	[OFST+6,s]
5060                     ; 491     return (len);
5062 f8e55 e681          	ldab	OFST-1,s
5064 f8e57 20c4          	bra	L22
5130                     ; 520 _NEAR void  OSFlagNameSet (OS_FLAG_GRP  *pgrp,
5130                     ; 521                           INT8U        *pname,
5130                     ; 522                           INT8U        *perr)
5130                     ; 523 {
5131                     	switch	.text
5132 f8e59               _OSFlagNameSet:
5134 f8e59 3b            	pshd	
5135 f8e5a 37            	pshb	
5136       00000001      OFST:	set	1
5139                     ; 525     OS_CPU_SR  cpu_sr = 0u;
5141                     ; 538     if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
5143 f8e5b 046404        	tbne	d,L5133
5144                     ; 539         *perr = OS_ERR_FLAG_INVALID_PGRP;
5146 f8e5e c66e          	ldab	#110
5147                     ; 540         return;
5149 f8e60 2006          	bra	LC009
5150 f8e62               L5133:
5151                     ; 542     if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
5153 f8e62 ec85          	ldd	OFST+4,s
5154 f8e64 2609          	bne	L7133
5155                     ; 543         *perr = OS_ERR_PNAME_NULL;
5157 f8e66 c60c          	ldab	#12
5158 f8e68               LC009:
5159 f8e68 6bf30007      	stab	[OFST+6,s]
5160                     ; 544         return;
5161 f8e6c               L62:
5164 f8e6c 1b83          	leas	3,s
5165 f8e6e 3d            	rts	
5166 f8e6f               L7133:
5167                     ; 547     if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
5169 f8e6f f6163c        	ldab	_OSIntNesting
5170 f8e72 2704          	beq	L1233
5171                     ; 548         *perr = OS_ERR_NAME_SET_ISR;
5173 f8e74 c612          	ldab	#18
5174                     ; 549         return;
5176 f8e76 20f0          	bra	LC009
5177 f8e78               L1233:
5178                     ; 551     OS_ENTER_CRITICAL();
5180 f8e78 164b4f        	jsr	_OS_CPU_SR_Save
5182 f8e7b 6b80          	stab	OFST-1,s
5183                     ; 552     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
5185 f8e7d ed81          	ldy	OFST+0,s
5186 f8e7f e640          	ldab	0,y
5187 f8e81 c105          	cmpb	#5
5188 f8e83 270a          	beq	L3233
5189                     ; 553         OS_EXIT_CRITICAL();
5191 f8e85 e680          	ldab	OFST-1,s
5192 f8e87 87            	clra	
5193 f8e88 164b54        	jsr	_OS_CPU_SR_Restore
5195                     ; 554         *perr = OS_ERR_EVENT_TYPE;
5197 f8e8b c601          	ldab	#1
5198                     ; 555         return;
5200 f8e8d 20d9          	bra	LC009
5201 f8e8f               L3233:
5202                     ; 557     pgrp->OSFlagName = pname;
5204 f8e8f 18028545      	movw	OFST+4,s,5,y
5205                     ; 558     OS_EXIT_CRITICAL();
5207 f8e93 e680          	ldab	OFST-1,s
5208 f8e95 87            	clra	
5209 f8e96 164b54        	jsr	_OS_CPU_SR_Restore
5211                     ; 560     *perr            = OS_ERR_NONE;
5214 f8e99 69f30007      	clr	[OFST+6,s]
5215                     ; 561     return;
5217 f8e9d 20cd          	bra	L62
5337                     ; 620 _NEAR OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *pgrp,
5337                     ; 621                            OS_FLAGS      flags,
5337                     ; 622                            INT8U         wait_type,
5337                     ; 623                            INT32U        timeout,
5337                     ; 624                            INT8U        *perr)
5337                     ; 625 {
5338                     	switch	.text
5339 f8e9f               _OSFlagPend:
5341 f8e9f 3b            	pshd	
5342 f8ea0 1b91          	leas	-15,s
5343       0000000f      OFST:	set	15
5346                     ; 632     OS_CPU_SR     cpu_sr = 0u;
5348                     ; 644     if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
5350 f8ea2 046404        	tbne	d,L1243
5351                     ; 645         *perr = OS_ERR_FLAG_INVALID_PGRP;
5353 f8ea5 c66e          	ldab	#110
5354                     ; 646         return ((OS_FLAGS)0);
5357 f8ea7 2007          	bra	LC010
5358 f8ea9               L1243:
5359                     ; 652     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
5362 f8ea9 f6163c        	ldab	_OSIntNesting
5363 f8eac 270c          	beq	L3243
5364                     ; 653         *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
5366 f8eae c602          	ldab	#2
5367                     ; 655         return ((OS_FLAGS)0);
5370 f8eb0               LC010:
5371 f8eb0 6bf3001b      	stab	[OFST+12,s]
5372 f8eb4 87            	clra	
5373 f8eb5 c7            	clrb	
5375 f8eb6               L23:
5377 f8eb6 1bf011        	leas	17,s
5378 f8eb9 3d            	rts	
5379 f8eba               L3243:
5380                     ; 657     if (OSLockNesting > 0u) {                              /* See if called with scheduler locked ...  */
5382 f8eba f6163b        	ldab	_OSLockNesting
5383 f8ebd 2704          	beq	L5243
5384                     ; 658         *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
5386 f8ebf c60d          	ldab	#13
5387                     ; 660         return ((OS_FLAGS)0);
5391 f8ec1 20ed          	bra	LC010
5392 f8ec3               L5243:
5393                     ; 662     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
5395 f8ec3 e6f3000f      	ldab	[OFST+0,s]
5396 f8ec7 c105          	cmpb	#5
5397 f8ec9 2704          	beq	L7243
5398                     ; 663         *perr = OS_ERR_EVENT_TYPE;
5400 f8ecb c601          	ldab	#1
5401                     ; 665         return ((OS_FLAGS)0);
5405 f8ecd 20e1          	bra	LC010
5406 f8ecf               L7243:
5407                     ; 667     result = (INT8U)(wait_type & OS_FLAG_CONSUME);
5409 f8ecf e6f016        	ldab	OFST+7,s
5410 f8ed2 c480          	andb	#128
5411 f8ed4 6b83          	stab	OFST-12,s
5412                     ; 668     if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
5414 f8ed6 270a          	beq	L1343
5415                     ; 669         wait_type &= (INT8U)~(INT8U)OS_FLAG_CONSUME;
5417 f8ed8 0df01680      	bclr	OFST+7,s,128
5418                     ; 670         consume    = OS_TRUE;
5420 f8edc c601          	ldab	#1
5421 f8ede 6b83          	stab	OFST-12,s
5423 f8ee0 2002          	bra	L3343
5424 f8ee2               L1343:
5425                     ; 672         consume    = OS_FALSE;
5427 f8ee2 6983          	clr	OFST-12,s
5428 f8ee4               L3343:
5429                     ; 675     OS_ENTER_CRITICAL();
5431 f8ee4 164b4f        	jsr	_OS_CPU_SR_Save
5433 f8ee7 6b82          	stab	OFST-13,s
5434                     ; 676     switch (wait_type) {
5436 f8ee9 e6f016        	ldab	OFST+7,s
5438 f8eec 275f          	beq	L1333
5439 f8eee 53            	decb	
5440 f8eef 277c          	beq	L3333
5441 f8ef1 04010d        	dbeq	b,L5233
5442 f8ef4 040122        	dbeq	b,L7233
5443                     ; 747         default:
5443                     ; 748              OS_EXIT_CRITICAL();
5446                     ; 749              flags_rdy = (OS_FLAGS)0;
5448                     ; 750              *perr      = OS_ERR_FLAG_WAIT_TYPE;
5450 f8ef7               LC011:
5451 f8ef7 e682          	ldab	OFST-13,s
5452 f8ef9 87            	clra	
5453 f8efa 164b54        	jsr	_OS_CPU_SR_Restore
5454 f8efd c66f          	ldab	#111
5455                     ; 752              return (flags_rdy);
5459 f8eff 20af          	bra	LC010
5460 f8f01               L5233:
5461                     ; 677         case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
5461                     ; 678              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
5463 f8f01 ed8f          	ldy	OFST+0,s
5464 f8f03 ec43          	ldd	3,y
5465 f8f05 e4f014        	andb	OFST+5,s
5466 f8f08 a4f013        	anda	OFST+4,s
5467 f8f0b 6c80          	std	OFST-15,s
5468                     ; 679              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
5470 f8f0d acf013        	cpd	OFST+4,s
5471 f8f10 266b          	bne	L3643
5472                     ; 680                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
5474 f8f12 e683          	ldab	OFST-12,s
5475 f8f14 53            	decb	
5476 f8f15 261f          	bne	L1543
5477                     ; 681                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;   /* Clear ONLY the flags we wanted    */
5479                     ; 683                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
5481                     ; 684                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
5484                     ; 685                  *perr                   = OS_ERR_NONE;
5486                     ; 687                  return (flags_rdy);
5490 f8f17 2013          	bra	LC017
5491                     ; 689                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
5494                     ; 690                  OS_EXIT_CRITICAL();
5497 f8f19               L7233:
5498                     ; 694         case OS_FLAG_WAIT_SET_ANY:
5498                     ; 695              flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
5500 f8f19 ed8f          	ldy	OFST+0,s
5501 f8f1b ec43          	ldd	3,y
5502 f8f1d e4f014        	andb	OFST+5,s
5503 f8f20 a4f013        	anda	OFST+4,s
5504 f8f23 6c80          	std	OFST-15,s
5505                     ; 696              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
5507 f8f25 2756          	beq	L3643
5508                     ; 697                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
5510 f8f27 e683          	ldab	OFST-12,s
5511 f8f29 04210a        	dbne	b,L1543
5512                     ; 698                      pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;    /* Clear ONLY the flags that we got */
5514 f8f2c               LC017:
5515 f8f2c ec80          	ldd	OFST-15,s
5516 f8f2e 51            	comb	
5517 f8f2f 41            	coma	
5518 f8f30 e444          	andb	4,y
5519 f8f32 a443          	anda	3,y
5520 f8f34               LC016:
5521 f8f34 6c43          	std	3,y
5522 f8f36               L1543:
5523                     ; 700                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
5525 f8f36 ec80          	ldd	OFST-15,s
5526 f8f38 fd1588        	ldy	_OSTCBCur
5527 f8f3b 6ce81c        	std	28,y
5528                     ; 701                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
5531                     ; 702                  *perr                   = OS_ERR_NONE;
5533 f8f3e               LC013:
5534 f8f3e e682          	ldab	OFST-13,s
5535 f8f40 87            	clra	
5536 f8f41 164b54        	jsr	_OS_CPU_SR_Restore
5537 f8f44 69f3001b      	clr	[OFST+12,s]
5538                     ; 704                  return (flags_rdy);
5541 f8f48               LC012:
5542 f8f48 ec80          	ldd	OFST-15,s
5544 f8f4a 064eb6        	bra	L23
5545                     ; 706                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
5548                     ; 707                  OS_EXIT_CRITICAL();
5551 f8f4d               L1333:
5552                     ; 712         case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
5552                     ; 713              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;    /* Extract only the bits we want     */
5554 f8f4d ed8f          	ldy	OFST+0,s
5555 f8f4f ec43          	ldd	3,y
5556 f8f51 51            	comb	
5557 f8f52 41            	coma	
5558 f8f53 e4f014        	andb	OFST+5,s
5559 f8f56 a4f013        	anda	OFST+4,s
5560 f8f59 6c80          	std	OFST-15,s
5561                     ; 714              if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
5563 f8f5b acf013        	cpd	OFST+4,s
5564 f8f5e 261d          	bne	L3643
5565                     ; 715                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
5567                     ; 716                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
5569 f8f60               LC018:
5570 f8f60 e683          	ldab	OFST-12,s
5571 f8f62 53            	decb	
5572 f8f63 26d1          	bne	L1543
5573 f8f65 ec43          	ldd	3,y
5574 f8f67 ea81          	orab	OFST-14,s
5575 f8f69 aa80          	oraa	OFST-15,s
5576                     ; 718                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
5578                     ; 719                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
5581                     ; 720                  *perr                   = OS_ERR_NONE;
5583                     ; 722                  return (flags_rdy);
5587 f8f6b 20c7          	bra	LC016
5588                     ; 724                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
5591                     ; 725                  OS_EXIT_CRITICAL();
5594 f8f6d               L3333:
5595                     ; 729         case OS_FLAG_WAIT_CLR_ANY:
5595                     ; 730              flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & flags;   /* Extract only the bits we want      */
5597 f8f6d ed8f          	ldy	OFST+0,s
5598 f8f6f ec43          	ldd	3,y
5599 f8f71 51            	comb	
5600 f8f72 41            	coma	
5601 f8f73 e4f014        	andb	OFST+5,s
5602 f8f76 a4f013        	anda	OFST+4,s
5603 f8f79 6c80          	std	OFST-15,s
5604                     ; 731              if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
5606                     ; 732                  if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
5608                     ; 733                      pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
5610                     ; 735                  OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
5612                     ; 736                  OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
5615                     ; 737                  *perr                   = OS_ERR_NONE;
5617                     ; 739                  return (flags_rdy);
5621 f8f7b 26e3          	bne	LC018
5622 f8f7d               L3643:
5623                     ; 741                  OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
5626                     ; 742                  OS_EXIT_CRITICAL();
5629 f8f7d ecf019        	ldd	OFST+10,s
5630 f8f80 3b            	pshd	
5631 f8f81 ecf019        	ldd	OFST+10,s
5632 f8f84 3b            	pshd	
5633 f8f85 e6f01a        	ldab	OFST+11,s
5634 f8f88 87            	clra	
5635 f8f89 3b            	pshd	
5636 f8f8a ecf019        	ldd	OFST+10,s
5637 f8f8d 3b            	pshd	
5638 f8f8e 1a8c          	leax	OFST-3,s
5639 f8f90 34            	pshx	
5640 f8f91 ecf019        	ldd	OFST+10,s
5641 f8f94 165165        	jsr	L3462_OS_FlagBlock
5642 f8f97 1b8a          	leas	10,s
5643 f8f99 e682          	ldab	OFST-13,s
5644 f8f9b 87            	clra	
5645 f8f9c 164b54        	jsr	_OS_CPU_SR_Restore
5646                     ; 755     OS_Sched();                                            /* Find next HPT ready to run               */
5648 f8f9f 164933        	jsr	_OS_Sched
5650                     ; 756     OS_ENTER_CRITICAL();
5652 f8fa2 164b4f        	jsr	_OS_CPU_SR_Save
5654 f8fa5 6b82          	stab	OFST-13,s
5655                     ; 757     if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
5657 f8fa7 fd1588        	ldy	_OSTCBCur
5658 f8faa e6e823        	ldab	35,y
5659 f8fad 2732          	beq	L1743
5660                     ; 758         pend_stat                = OSTCBCur->OSTCBStatPend;
5662 f8faf 6b83          	stab	OFST-12,s
5663                     ; 759         OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
5665 f8fb1 69e823        	clr	35,y
5666                     ; 760         OS_FlagUnlink(&node);
5668 f8fb4 b774          	tfr	s,d
5669 f8fb6 c30004        	addd	#-11+OFST
5670 f8fb9 16528b        	jsr	_OS_FlagUnlink
5672                     ; 761         OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
5674 f8fbc fd1588        	ldy	_OSTCBCur
5675 f8fbf 87            	clra	
5676 f8fc0 6ae822        	staa	34,y
5677                     ; 762         OS_EXIT_CRITICAL();
5679 f8fc3 e682          	ldab	OFST-13,s
5680 f8fc5 164b54        	jsr	_OS_CPU_SR_Restore
5682                     ; 763         flags_rdy                = (OS_FLAGS)0;
5684 f8fc8 87            	clra	
5685 f8fc9 c7            	clrb	
5686 f8fca 6c80          	std	OFST-15,s
5687                     ; 764         switch (pend_stat) {
5689 f8fcc e683          	ldab	OFST-12,s
5691 f8fce 040107        	dbeq	b,L1433
5692 f8fd1 042104        	dbne	b,L1433
5693                     ; 765             case OS_STAT_PEND_ABORT:
5693                     ; 766                  *perr = OS_ERR_PEND_ABORT;                /* Indicate that we aborted   waiting       */
5695 f8fd4 c60e          	ldab	#14
5696                     ; 767                  break;
5698 f8fd6 2002          	bra	L5743
5699 f8fd8               L1433:
5700                     ; 769             case OS_STAT_PEND_TO:
5700                     ; 770             default:
5700                     ; 771                  *perr = OS_ERR_TIMEOUT;                   /* Indicate that we timed-out waiting       */
5702 f8fd8 c60a          	ldab	#10
5703                     ; 772                  break;
5705 f8fda               L5743:
5706 f8fda 6bf3001b      	stab	[OFST+12,s]
5707                     ; 775         return (flags_rdy);
5711 f8fde 064f48        	bra	LC012
5712 f8fe1               L1743:
5713                     ; 777     flags_rdy = OSTCBCur->OSTCBFlagsRdy;
5715 f8fe1 ece81c        	ldd	28,y
5716 f8fe4 6c80          	std	OFST-15,s
5717                     ; 778     if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
5719 f8fe6 e683          	ldab	OFST-12,s
5720 f8fe8 53            	decb	
5721 f8fe9 1826ff51      	bne	LC013
5722                     ; 779         switch (wait_type) {
5724 f8fed e6f016        	ldab	OFST+7,s
5726 f8ff0 2718          	beq	L5433
5727 f8ff2 040115        	dbeq	b,L5433
5728 f8ff5 040106        	dbeq	b,L3433
5729 f8ff8 040103        	dbeq	b,L3433
5730                     ; 791             default:
5730                     ; 792                  OS_EXIT_CRITICAL();
5733                     ; 793                  *perr = OS_ERR_FLAG_WAIT_TYPE;
5735                     ; 795                  return ((OS_FLAGS)0);
5739 f8ffb 064ef7        	bra	LC011
5740 f8ffe               L3433:
5741                     ; 780             case OS_FLAG_WAIT_SET_ALL:
5741                     ; 781             case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
5741                     ; 782                  pgrp->OSFlagFlags &= (OS_FLAGS)~flags_rdy;
5743 f8ffe ed8f          	ldy	OFST+0,s
5744 f9000 ec80          	ldd	OFST-15,s
5745 f9002 51            	comb	
5746 f9003 41            	coma	
5747 f9004 e444          	andb	4,y
5748 f9006 a443          	anda	3,y
5749                     ; 783                  break;
5751 f9008 2008          	bra	LC015
5752 f900a               L5433:
5753                     ; 786             case OS_FLAG_WAIT_CLR_ALL:
5753                     ; 787             case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
5753                     ; 788                  pgrp->OSFlagFlags |=  flags_rdy;
5755 f900a ed8f          	ldy	OFST+0,s
5756 f900c ec43          	ldd	3,y
5757 f900e ea81          	orab	OFST-14,s
5758 f9010 aa80          	oraa	OFST-15,s
5759 f9012               LC015:
5760 f9012 6c43          	std	3,y
5761                     ; 789                  break;
5763                     ; 798     OS_EXIT_CRITICAL();
5766                     ; 799     *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
5768                     ; 801     return (flags_rdy);
5772 f9014 064f3e        	bra	LC013
5814                     ; 820 _NEAR OS_FLAGS  OSFlagPendGetFlagsRdy (void)
5814                     ; 821 {
5815                     	switch	.text
5816 f9017               _OSFlagPendGetFlagsRdy:
5818 f9017 1b9d          	leas	-3,s
5819       00000003      OFST:	set	3
5822                     ; 824     OS_CPU_SR     cpu_sr = 0u;
5824                     ; 829     OS_ENTER_CRITICAL();
5826 f9019 164b4f        	jsr	_OS_CPU_SR_Save
5828 f901c 6b80          	stab	OFST-3,s
5829                     ; 830     flags = OSTCBCur->OSTCBFlagsRdy;
5831 f901e fd1588        	ldy	_OSTCBCur
5832 f9021 ece81c        	ldd	28,y
5833 f9024 6c81          	std	OFST-2,s
5834                     ; 831     OS_EXIT_CRITICAL();
5836 f9026 e680          	ldab	OFST-3,s
5837 f9028 87            	clra	
5838 f9029 164b54        	jsr	_OS_CPU_SR_Restore
5840                     ; 832     return (flags);
5842 f902c ec81          	ldd	OFST-2,s
5845 f902e 1b83          	leas	3,s
5846 f9030 3d            	rts	
5957                     ; 877 _NEAR OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *pgrp,
5957                     ; 878                            OS_FLAGS      flags,
5957                     ; 879                            INT8U         opt,
5957                     ; 880                            INT8U        *perr)
5957                     ; 881 {
5958                     	switch	.text
5959 f9031               _OSFlagPost:
5961 f9031 3b            	pshd	
5962 f9032 1b99          	leas	-7,s
5963       00000007      OFST:	set	7
5966                     ; 888     OS_CPU_SR     cpu_sr = 0u;
5968                     ; 900     if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
5970 f9034 046404        	tbne	d,L3163
5971                     ; 901         *perr = OS_ERR_FLAG_INVALID_PGRP;
5973 f9037 c66e          	ldab	#110
5974                     ; 902         return ((OS_FLAGS)0);
5977 f9039 200a          	bra	L04
5978 f903b               L3163:
5979                     ; 908     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
5982 f903b e6f30007      	ldab	[OFST+0,s]
5983 f903f c105          	cmpb	#5
5984 f9041 270b          	beq	L5163
5985                     ; 909         *perr = OS_ERR_EVENT_TYPE;
5987 f9043 c601          	ldab	#1
5988                     ; 911         return ((OS_FLAGS)0);
5992 f9045               L04:
5993 f9045 6bf3000f      	stab	[OFST+8,s]
5994 f9049 87            	clra	
5995 f904a c7            	clrb	
5997 f904b 1b89          	leas	9,s
5998 f904d 3d            	rts	
5999 f904e               L5163:
6000                     ; 914     OS_ENTER_CRITICAL();
6002 f904e 164b4f        	jsr	_OS_CPU_SR_Save
6004 f9051 6b86          	stab	OFST-1,s
6005                     ; 915     switch (opt) {
6007 f9053 e68e          	ldab	OFST+7,s
6009 f9055 270d          	beq	L3253
6010 f9057 040116        	dbeq	b,L5253
6011                     ; 924         default:
6011                     ; 925              OS_EXIT_CRITICAL();                     /* INVALID option                                 */
6013 f905a e686          	ldab	OFST-1,s
6014 f905c 87            	clra	
6015 f905d 164b54        	jsr	_OS_CPU_SR_Restore
6017                     ; 926              *perr = OS_ERR_FLAG_INVALID_OPT;
6019 f9060 c671          	ldab	#113
6020                     ; 928              return ((OS_FLAGS)0);
6024 f9062 20e1          	bra	L04
6025 f9064               L3253:
6026                     ; 916         case OS_FLAG_CLR:
6026                     ; 917              pgrp->OSFlagFlags &= (OS_FLAGS)~flags;  /* Clear the flags specified in the group         */
6028 f9064 ed87          	ldy	OFST+0,s
6029 f9066 ec8b          	ldd	OFST+4,s
6030 f9068 51            	comb	
6031 f9069 41            	coma	
6032 f906a e444          	andb	4,y
6033 f906c a443          	anda	3,y
6034                     ; 918              break;
6036 f906e 2008          	bra	L1263
6037 f9070               L5253:
6038                     ; 920         case OS_FLAG_SET:
6038                     ; 921              pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
6040 f9070 ed87          	ldy	OFST+0,s
6041 f9072 ec43          	ldd	3,y
6042 f9074 ea8c          	orab	OFST+5,s
6043 f9076 aa8b          	oraa	OFST+4,s
6044                     ; 922              break;
6046 f9078               L1263:
6047 f9078 6c43          	std	3,y
6048                     ; 930     sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
6050 f907a 6985          	clr	OFST-2,s
6051                     ; 931     pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
6053 f907c ec41          	ldd	1,y
6055 f907e 065106        	bra	L5263
6056 f9081               L3263:
6057                     ; 933         switch (pnode->OSFlagNodeWaitType) {
6059 f9081 b746          	tfr	d,y
6060 f9083 e64a          	ldab	10,y
6062 f9085 2741          	beq	L5353
6063 f9087 53            	decb	
6064 f9088 2752          	beq	L7353
6065 f908a 04010d        	dbeq	b,L1353
6066 f908d 04012e        	dbeq	b,L3353
6067                     ; 975             default:
6067                     ; 976                  OS_EXIT_CRITICAL();
6069 f9090 e686          	ldab	OFST-1,s
6070 f9092 87            	clra	
6071 f9093 164b54        	jsr	_OS_CPU_SR_Restore
6073                     ; 977                  *perr = OS_ERR_FLAG_WAIT_TYPE;
6075 f9096 c66f          	ldab	#111
6076                     ; 979                  return ((OS_FLAGS)0);
6080 f9098 20ab          	bra	L04
6081 f909a               L1353:
6082                     ; 934             case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
6082                     ; 935                  flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
6084 f909a ec48          	ldd	8,y
6085 f909c ed87          	ldy	OFST+0,s
6086 f909e e444          	andb	4,y
6087 f90a0 a443          	anda	3,y
6088 f90a2 6c82          	std	OFST-5,s
6089                     ; 936                  if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
6091 f90a4 ed80          	ldy	OFST-7,s
6092 f90a6 ac48          	cpd	8,y
6093 f90a8 2658          	bne	L3363
6094                     ; 937                      rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
6096 f90aa 87            	clra	
6097 f90ab c7            	clrb	
6098 f90ac 3b            	pshd	
6099 f90ad ec84          	ldd	OFST-3,s
6100 f90af 3b            	pshd	
6101 f90b0 b764          	tfr	y,d
6102 f90b2 16523b        	jsr	L5462_OS_FlagTaskRdy
6104 f90b5 1b84          	leas	4,s
6105 f90b7 6b84          	stab	OFST-3,s
6106                     ; 938                      if (rdy == OS_TRUE) {
6108 f90b9 53            	decb	
6109 f90ba 2646          	bne	L3363
6110                     ; 939                          sched = OS_TRUE;                     /* When done we will reschedule          */
6112 f90bc 2040          	bra	LC019
6113 f90be               L3353:
6114                     ; 944             case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
6114                     ; 945                  flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
6116 f90be ec48          	ldd	8,y
6117 f90c0 ed87          	ldy	OFST+0,s
6118 f90c2 e444          	andb	4,y
6119 f90c4 a443          	anda	3,y
6120                     ; 946                  if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
6122                     ; 947                      rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
6125                     ; 948                      if (rdy == OS_TRUE) {
6127                     ; 949                          sched = OS_TRUE;                     /* When done we will reschedule          */
6129 f90c6 2020          	bra	LC021
6130 f90c8               L5353:
6131                     ; 955             case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
6131                     ; 956                  flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
6133 f90c8 ed87          	ldy	OFST+0,s
6134 f90ca ec43          	ldd	3,y
6135 f90cc 51            	comb	
6136 f90cd 41            	coma	
6137 f90ce ed80          	ldy	OFST-7,s
6138 f90d0 e449          	andb	9,y
6139 f90d2 a448          	anda	8,y
6140 f90d4 6c82          	std	OFST-5,s
6141                     ; 957                  if (flags_rdy == pnode->OSFlagNodeFlags) {   /* Make task RTR, event(s) Rx'd          */
6143 f90d6 ac48          	cpd	8,y
6144 f90d8 2628          	bne	L3363
6145                     ; 958                      rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
6148                     ; 959                      if (rdy == OS_TRUE) {
6150                     ; 960                          sched = OS_TRUE;                     /* When done we will reschedule          */
6152 f90da 2010          	bra	LC020
6153 f90dc               L7353:
6154                     ; 965             case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
6154                     ; 966                  flags_rdy = (OS_FLAGS)~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags;
6156 f90dc ed87          	ldy	OFST+0,s
6157 f90de ec43          	ldd	3,y
6158 f90e0 51            	comb	
6159 f90e1 41            	coma	
6160 f90e2 ed80          	ldy	OFST-7,s
6161 f90e4 e449          	andb	9,y
6162 f90e6 a448          	anda	8,y
6163                     ; 967                  if (flags_rdy != (OS_FLAGS)0) {              /* Make task RTR, event(s) Rx'd          */
6165 f90e8               LC021:
6166 f90e8 6c82          	std	OFST-5,s
6167 f90ea 2716          	beq	L3363
6168                     ; 968                      rdy = OS_FlagTaskRdy(pnode, flags_rdy, OS_STAT_PEND_OK);
6171                     ; 969                      if (rdy == OS_TRUE) {
6173 f90ec               LC020:
6174 f90ec 87            	clra	
6175 f90ed c7            	clrb	
6176 f90ee 3b            	pshd	
6177 f90ef ec84          	ldd	OFST-3,s
6178 f90f1 3b            	pshd	
6179 f90f2 ec84          	ldd	OFST-3,s
6180 f90f4 16523b        	jsr	L5462_OS_FlagTaskRdy
6181 f90f7 1b84          	leas	4,s
6182 f90f9 6b84          	stab	OFST-3,s
6183 f90fb 042104        	dbne	b,L3363
6184                     ; 970                          sched = OS_TRUE;                     /* When done we will reschedule          */
6186 f90fe               LC019:
6187 f90fe c601          	ldab	#1
6188 f9100 6b85          	stab	OFST-2,s
6189 f9102               L3363:
6190                     ; 981         pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
6192 f9102 ecf30000      	ldd	[OFST-7,s]
6193 f9106               L5263:
6194 f9106 6c80          	std	OFST-7,s
6195                     ; 932     while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
6197 f9108 1826ff75      	bne	L3263
6198                     ; 983     OS_EXIT_CRITICAL();
6200 f910c e686          	ldab	OFST-1,s
6201 f910e 164b54        	jsr	_OS_CPU_SR_Restore
6203                     ; 984     if (sched == OS_TRUE) {
6205 f9111 e685          	ldab	OFST-2,s
6206 f9113 042103        	dbne	b,L5563
6207                     ; 985         OS_Sched();
6209 f9116 164933        	jsr	_OS_Sched
6211 f9119               L5563:
6212                     ; 987     OS_ENTER_CRITICAL();
6214 f9119 164b4f        	jsr	_OS_CPU_SR_Save
6216 f911c 6b86          	stab	OFST-1,s
6217                     ; 988     flags_cur = pgrp->OSFlagFlags;
6219 f911e ed87          	ldy	OFST+0,s
6220 f9120 18024382      	movw	3,y,OFST-5,s
6221                     ; 989     OS_EXIT_CRITICAL();
6223 f9124 87            	clra	
6224 f9125 164b54        	jsr	_OS_CPU_SR_Restore
6226                     ; 990     *perr     = OS_ERR_NONE;
6228 f9128 69f3000f      	clr	[OFST+8,s]
6229                     ; 993     return (flags_cur);
6232 f912c ec82          	ldd	OFST-5,s
6235 f912e 1b89          	leas	9,s
6236 f9130 3d            	rts	
6298                     ; 1017 _NEAR OS_FLAGS  OSFlagQuery (OS_FLAG_GRP  *pgrp,
6298                     ; 1018                             INT8U        *perr)
6298                     ; 1019 {
6299                     	switch	.text
6300 f9131               _OSFlagQuery:
6302 f9131 3b            	pshd	
6303 f9132 1b9d          	leas	-3,s
6304       00000003      OFST:	set	3
6307                     ; 1022     OS_CPU_SR  cpu_sr = 0u;
6309                     ; 1035     if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
6311 f9134 046404        	tbne	d,L7073
6312                     ; 1036         *perr = OS_ERR_FLAG_INVALID_PGRP;
6314 f9137 c66e          	ldab	#110
6315                     ; 1037         return ((OS_FLAGS)0);
6318 f9139 200a          	bra	LC022
6319 f913b               L7073:
6320                     ; 1040     if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
6322 f913b e6f30003      	ldab	[OFST+0,s]
6323 f913f c105          	cmpb	#5
6324 f9141 270b          	beq	L1173
6325                     ; 1041         *perr = OS_ERR_EVENT_TYPE;
6327 f9143 c601          	ldab	#1
6328                     ; 1042         return ((OS_FLAGS)0);
6330 f9145               LC022:
6331 f9145 6bf30007      	stab	[OFST+4,s]
6332 f9149 87            	clra	
6333 f914a c7            	clrb	
6335 f914b               L44:
6337 f914b 1b85          	leas	5,s
6338 f914d 3d            	rts	
6339 f914e               L1173:
6340                     ; 1044     OS_ENTER_CRITICAL();
6342 f914e 164b4f        	jsr	_OS_CPU_SR_Save
6344 f9151 6b80          	stab	OFST-3,s
6345                     ; 1045     flags = pgrp->OSFlagFlags;
6347 f9153 ed83          	ldy	OFST+0,s
6348 f9155 18024381      	movw	3,y,OFST-2,s
6349                     ; 1046     OS_EXIT_CRITICAL();
6351 f9159 87            	clra	
6352 f915a 164b54        	jsr	_OS_CPU_SR_Restore
6354                     ; 1047     *perr = OS_ERR_NONE;
6356 f915d 69f30007      	clr	[OFST+4,s]
6357                     ; 1048     return (flags);                               /* Return the current value of the event flags       */
6359 f9161 ec81          	ldd	OFST-2,s
6361 f9163 20e6          	bra	L44
6452                     ; 1090 static  void  OS_FlagBlock (OS_FLAG_GRP  *pgrp,
6452                     ; 1091                             OS_FLAG_NODE *pnode,
6452                     ; 1092                             OS_FLAGS      flags,
6452                     ; 1093                             INT8U         wait_type,
6452                     ; 1094                             INT32U        timeout)
6452                     ; 1095 {
6453                     	switch	.text
6454 f9165               L3462_OS_FlagBlock:
6456 f9165 3b            	pshd	
6457 f9166 1b9d          	leas	-3,s
6458       00000003      OFST:	set	3
6461                     ; 1100     OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
6463 f9168 fd1588        	ldy	_OSTCBCur
6464 f916b 0ce82220      	bset	34,y,32
6465                     ; 1101     OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
6467 f916f 69e823        	clr	35,y
6468                     ; 1102     OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
6470 f9172 ec8f          	ldd	OFST+12,s
6471 f9174 6ce820        	std	32,y
6472 f9177 ec8d          	ldd	OFST+10,s
6473 f9179 6ce81e        	std	30,y
6474                     ; 1104     OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
6476 f917c ec87          	ldd	OFST+4,s
6477 f917e 6ce81a        	std	26,y
6478                     ; 1106     pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
6480 f9181 b746          	tfr	d,y
6481 f9183 18028948      	movw	OFST+6,s,8,y
6482                     ; 1107     pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
6484 f9187 180a8c4a      	movb	OFST+9,s,10,y
6485                     ; 1108     pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
6487 f918b 1801441588    	movw	_OSTCBCur,4,y
6488                     ; 1109     pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
6490 f9190 ee83          	ldx	OFST+0,s
6491 f9192 ed87          	ldy	OFST+4,s
6492 f9194 18020140      	movw	1,x,0,y
6493                     ; 1110     pnode->OSFlagNodePrev     = (void *)0;
6495 f9198 87            	clra	
6496 f9199 c7            	clrb	
6497 f919a 6c42          	std	2,y
6498                     ; 1111     pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
6500 f919c 18028346      	movw	OFST+0,s,6,y
6501                     ; 1112     pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
6503 f91a0 ed83          	ldy	OFST+0,s
6504 f91a2 ed41          	ldy	1,y
6505 f91a4 6d80          	sty	OFST-3,s
6506                     ; 1113     if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
6508 f91a6 2704          	beq	L7573
6509                     ; 1114         pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
6511 f91a8 18028742      	movw	OFST+4,s,2,y
6512 f91ac               L7573:
6513                     ; 1116     pgrp->OSFlagWaitList = (void *)pnode;
6515 f91ac ed83          	ldy	OFST+0,s
6516 f91ae 18028741      	movw	OFST+4,s,1,y
6517                     ; 1118     y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
6519 f91b2 fd1588        	ldy	_OSTCBCur
6520 f91b5 e6e826        	ldab	38,y
6521                     ; 1119     OSRdyTbl[y] &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
6523 f91b8 b796          	exg	b,y
6524 f91ba fe1588        	ldx	_OSTCBCur
6525 f91bd e6e027        	ldab	39,x
6526 f91c0 51            	comb	
6527 f91c1 e4ea1630      	andb	_OSRdyTbl,y
6528 f91c5 6bea1630      	stab	_OSRdyTbl,y
6529                     ; 1121     if (OSRdyTbl[y] == 0x00u) {
6532 f91c9 260c          	bne	L1673
6533                     ; 1122         OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
6535 f91cb b756          	tfr	x,y
6536 f91cd e6e828        	ldab	40,y
6537 f91d0 51            	comb	
6538 f91d1 f41638        	andb	_OSRdyGrp
6539 f91d4 7b1638        	stab	_OSRdyGrp
6540 f91d7               L1673:
6541                     ; 1124 }
6544 f91d7 1b85          	leas	5,s
6545 f91d9 3d            	rts	
6610                     ; 1142 _NEAR void  OS_FlagInit (void)
6610                     ; 1143 {
6611                     	switch	.text
6612 f91da               _OS_FlagInit:
6614 f91da 1b9a          	leas	-6,s
6615       00000006      OFST:	set	6
6618                     ; 1161     OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
6620 f91dc cc0023        	ldd	#35
6621 f91df 3b            	pshd	
6622 f91e0 cc163f        	ldd	#_OSFlagTbl
6623 f91e3 164907        	jsr	_OS_MemClr
6625 f91e6 1b82          	leas	2,s
6626                     ; 1162     for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
6628 f91e8 87            	clra	
6629 f91e9 c7            	clrb	
6630 f91ea b746          	tfr	d,y
6631 f91ec 6d82          	sty	OFST-4,s
6632 f91ee               L5104:
6633                     ; 1163         ix_next = ix + 1u;
6635 f91ee 02            	iny	
6636 f91ef 6d84          	sty	OFST-2,s
6637                     ; 1164         pgrp1 = &OSFlagTbl[ix];
6639 f91f1 cd0007        	ldy	#7
6640 f91f4 13            	emul	
6641 f91f5 c3163f        	addd	#_OSFlagTbl
6642 f91f8 6c80          	std	OFST-6,s
6643                     ; 1165         pgrp2 = &OSFlagTbl[ix_next];
6645 f91fa ec84          	ldd	OFST-2,s
6646 f91fc cd0007        	ldy	#7
6647 f91ff 13            	emul	
6648 f9200 c3163f        	addd	#_OSFlagTbl
6649 f9203 6c84          	std	OFST-2,s
6650                     ; 1166         pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
6652 f9205 ed80          	ldy	OFST-6,s
6653 f9207 6940          	clr	0,y
6654                     ; 1167         pgrp1->OSFlagWaitList = (void *)pgrp2;
6656 f9209 6c41          	std	1,y
6657                     ; 1169         pgrp1->OSFlagName     = (INT8U *)(void *)"?";               /* Unknown name                    */
6659 f920b cc7733        	ldd	#L1503
6660 f920e 6c45          	std	5,y
6661                     ; 1162     for (ix = 0u; ix < (OS_MAX_FLAGS - 1u); ix++) {                 /* Init. list of free EVENT FLAGS  */
6663 f9210 ed82          	ldy	OFST-4,s
6664 f9212 02            	iny	
6667 f9213 b764          	tfr	y,d
6668 f9215 6c82          	std	OFST-4,s
6669 f9217 8c0004        	cpd	#4
6670 f921a 25d2          	blo	L5104
6671                     ; 1172     pgrp1                 = &OSFlagTbl[ix];
6673 f921c cd0007        	ldy	#7
6674 f921f 13            	emul	
6675 f9220 c3163f        	addd	#_OSFlagTbl
6676 f9223 6c80          	std	OFST-6,s
6677                     ; 1173     pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
6679 f9225 87            	clra	
6680 f9226 ed80          	ldy	OFST-6,s
6681 f9228 6a40          	staa	0,y
6682                     ; 1174     pgrp1->OSFlagWaitList = (void *)0;
6684 f922a c7            	clrb	
6685 f922b 6c41          	std	1,y
6686                     ; 1176     pgrp1->OSFlagName     = (INT8U *)(void *)"?";                   /* Unknown name                    */
6688 f922d cc7733        	ldd	#L1503
6689 f9230 6c45          	std	5,y
6690                     ; 1178     OSFlagFreeList        = &OSFlagTbl[0];
6692 f9232 cc163f        	ldd	#_OSFlagTbl
6693 f9235 7c163d        	std	_OSFlagFreeList
6694                     ; 1180 }
6697 f9238 1b86          	leas	6,s
6698 f923a 3d            	rts	
7087                     ; 1209 static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode,
7087                     ; 1210                                  OS_FLAGS      flags_rdy,
7087                     ; 1211                                  INT8U         pend_stat)
7087                     ; 1212 {
7088                     	switch	.text
7089 f923b               L5462_OS_FlagTaskRdy:
7091 f923b 3b            	pshd	
7092 f923c 1b9d          	leas	-3,s
7093       00000003      OFST:	set	3
7096                     ; 1217     ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
7098 f923e b746          	tfr	d,y
7099 f9240 ed44          	ldy	4,y
7100 f9242 6d80          	sty	OFST-3,s
7101                     ; 1218     ptcb->OSTCBDly       = 0u;
7103 f9244 87            	clra	
7104 f9245 c7            	clrb	
7105 f9246 6ce820        	std	32,y
7106 f9249 6ce81e        	std	30,y
7107                     ; 1219     ptcb->OSTCBFlagsRdy  = flags_rdy;
7109 f924c ec87          	ldd	OFST+4,s
7110 f924e 6ce81c        	std	28,y
7111                     ; 1220     ptcb->OSTCBStat     &= (INT8U)~(INT8U)OS_STAT_FLAG;
7113 f9251 0de82220      	bclr	34,y,32
7114                     ; 1221     ptcb->OSTCBStatPend  = pend_stat;
7116 f9255 e68a          	ldab	OFST+7,s
7117 f9257 6be823        	stab	35,y
7118                     ; 1222     if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
7120 f925a e6e822        	ldab	34,y
7121 f925d 2621          	bne	L7424
7122                     ; 1223         OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
7124 f925f e6e828        	ldab	40,y
7125 f9262 fa1638        	orab	_OSRdyGrp
7126 f9265 7b1638        	stab	_OSRdyGrp
7127                     ; 1224         OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
7129 f9268 e6e826        	ldab	38,y
7130 f926b b796          	exg	b,y
7131 f926d ee80          	ldx	OFST-3,s
7132 f926f e6e027        	ldab	39,x
7133 f9272 eaea1630      	orab	_OSRdyTbl,y
7134 f9276 6bea1630      	stab	_OSRdyTbl,y
7135                     ; 1226         sched                   = OS_TRUE;
7138 f927a c601          	ldab	#1
7139 f927c 6b82          	stab	OFST-1,s
7141 f927e 2002          	bra	L1524
7142 f9280               L7424:
7143                     ; 1228         sched                   = OS_FALSE;
7145 f9280 6982          	clr	OFST-1,s
7146 f9282               L1524:
7147                     ; 1230     OS_FlagUnlink(pnode);
7149 f9282 ec83          	ldd	OFST+0,s
7150 f9284 0705          	jsr	_OS_FlagUnlink
7152                     ; 1231     return (sched);
7154 f9286 e682          	ldab	OFST-1,s
7157 f9288 1b85          	leas	5,s
7158 f928a 3d            	rts	
7242                     ; 1256 _NEAR void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
7242                     ; 1257 {
7243                     	switch	.text
7244 f928b               _OS_FlagUnlink:
7246 f928b 3b            	pshd	
7247 f928c 1b9c          	leas	-4,s
7248       00000004      OFST:	set	4
7251                     ; 1266     pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
7253 f928e b746          	tfr	d,y
7254 f9290 18024280      	movw	2,y,OFST-4,s
7255                     ; 1267     pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
7257 f9294 ed84          	ldy	OFST+0,s
7258 f9296 ec40          	ldd	0,y
7259 f9298 6c82          	std	OFST-2,s
7260                     ; 1268     if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
7262 f929a ee80          	ldx	OFST-4,s
7263 f929c 260e          	bne	L3234
7264                     ; 1269         pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
7266 f929e ed46          	ldy	6,y
7267 f92a0 6d80          	sty	OFST-4,s
7268                     ; 1270         pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
7270 f92a2 6c41          	std	1,y
7271                     ; 1271         if (pnode_next != (OS_FLAG_NODE *)0) {
7273 f92a4 2710          	beq	L7234
7274                     ; 1272             pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
7276 f92a6 87            	clra	
7277 f92a7 c7            	clrb	
7278 f92a8 ed82          	ldy	OFST-2,s
7279 f92aa 2008          	bra	LC023
7280 f92ac               L3234:
7281                     ; 1275         pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
7283 f92ac b746          	tfr	d,y
7284 f92ae 6d00          	sty	0,x
7285                     ; 1276         if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
7287 f92b0 2704          	beq	L7234
7288                     ; 1277             pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
7290 f92b2 b754          	tfr	x,d
7291 f92b4               LC023:
7292 f92b4 6c42          	std	2,y
7293 f92b6               L7234:
7294                     ; 1281     ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
7296 f92b6 ed84          	ldy	OFST+0,s
7297 f92b8 ed44          	ldy	4,y
7298                     ; 1282     ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
7300 f92ba 87            	clra	
7301 f92bb c7            	clrb	
7302 f92bc 6ce81a        	std	26,y
7303                     ; 1284 }
7306 f92bf 1b86          	leas	6,s
7307 f92c1 3d            	rts	
7319                     	xref	_OS_StrLen
7320                     	xref	_OS_Sched
7321                     	xref	_OS_MemClr
7322                     	xdef	_OS_FlagUnlink
7323                     	xdef	_OS_FlagInit
7324                     	xdef	_OSFlagQuery
7325                     	xdef	_OSFlagPost
7326                     	xdef	_OSFlagPendGetFlagsRdy
7327                     	xdef	_OSFlagPend
7328                     	xdef	_OSFlagNameSet
7329                     	xdef	_OSFlagNameGet
7330                     	xdef	_OSFlagDel
7331                     	xdef	_OSFlagCreate
7332                     	xdef	_OSFlagAccept
7333                     	xref	_OSTCBCur
7334                     	xref	_OSRdyTbl
7335                     	xref	_OSRdyGrp
7336                     	xref	_OSLockNesting
7337                     	xref	_OSIntNesting
7338                     	xref	_OSFlagFreeList
7339                     	xref	_OSFlagTbl
7340                     	xref	_OS_CPU_SR_Restore
7341                     	xref	_OS_CPU_SR_Save
7342                     .const:	section	.data
7343 fb733               L1503:
7344 fb733 3f00          	dc.b	"?",0
7365                     	end
