   1                     ; C Compiler for 68HCS12 [COSMIC Software]
   2                     ; Parser V4.11.9 - 08 Feb 2017
   3                     ; Generator V4.8.12 - 22 Feb 2017
   4                     ; Optimizer V4.7.11 - 22 Feb 2017
 134                     ; 56 _NEAR void  *OSMboxAccept (OS_EVENT *pevent)
 134                     ; 57 {
 135                     	switch	.text
 136 f91b5               _OSMboxAccept:
 138 f91b5 3b            	pshd	
 139 f91b6 1b9d          	leas	-3,s
 140       00000003      OFST:	set	3
 143                     ; 60     OS_CPU_SR  cpu_sr = 0u;
 145                     ; 66     if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
 147 f91b8 046402        	tbne	d,L56
 148                     ; 67         return ((void *)0);
 151 f91bb 2007          	bra	LC001
 152 f91bd               L56:
 153                     ; 70     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
 155 f91bd e6f30003      	ldab	[OFST+0,s]
 156 f91c1 040105        	dbeq	b,L76
 157                     ; 71         return ((void *)0);
 159 f91c4               LC001:
 160 f91c4 87            	clra	
 161 f91c5 c7            	clrb	
 163 f91c6               L6:
 165 f91c6 1b85          	leas	5,s
 166 f91c8 3d            	rts	
 167 f91c9               L76:
 168                     ; 73     OS_ENTER_CRITICAL();
 170 f91c9 167522        	jsr	_OS_CPU_SR_Save
 172 f91cc 6b80          	stab	OFST-3,s
 173                     ; 74     pmsg               = pevent->OSEventPtr;
 175 f91ce ed83          	ldy	OFST+0,s
 176 f91d0 18024181      	movw	1,y,OFST-2,s
 177                     ; 75     pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
 179 f91d4 87            	clra	
 180 f91d5 c7            	clrb	
 181 f91d6 6c41          	std	1,y
 182                     ; 76     OS_EXIT_CRITICAL();
 184 f91d8 e680          	ldab	OFST-3,s
 185 f91da 167527        	jsr	_OS_CPU_SR_Restore
 187                     ; 77     return (pmsg);                                        /* Return the message received (or NULL)     */
 189 f91dd ec81          	ldd	OFST-2,s
 191 f91df 20e5          	bra	L6
 252                     ; 98 _NEAR OS_EVENT  *OSMboxCreate (void *pmsg)
 252                     ; 99 {
 253                     	switch	.text
 254 f91e1               _OSMboxCreate:
 256 f91e1 3b            	pshd	
 257 f91e2 1b9d          	leas	-3,s
 258       00000003      OFST:	set	3
 261                     ; 102     OS_CPU_SR  cpu_sr = 0u;
 263                     ; 114     if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
 265 f91e4 f61631        	ldab	_OSIntNesting
 266 f91e7 2704          	beq	L121
 267                     ; 115         return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 269 f91e9 87            	clra	
 270 f91ea c7            	clrb	
 272 f91eb 2031          	bra	L21
 273 f91ed               L121:
 274                     ; 117     OS_ENTER_CRITICAL();
 276 f91ed 167522        	jsr	_OS_CPU_SR_Save
 278 f91f0 6b82          	stab	OFST-1,s
 279                     ; 118     pevent = OSEventFreeList;                    /* Get next free event control block                  */
 281 f91f2 fd16f7        	ldy	_OSEventFreeList
 282 f91f5 6d80          	sty	OFST-3,s
 283                     ; 119     if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 285 f91f7 2705          	beq	L321
 286                     ; 120         OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 288 f91f9 18054116f7    	movw	1,y,_OSEventFreeList
 289 f91fe               L321:
 290                     ; 122     OS_EXIT_CRITICAL();
 292 f91fe 87            	clra	
 293 f91ff 167527        	jsr	_OS_CPU_SR_Restore
 295                     ; 123     if (pevent != (OS_EVENT *)0) {
 297 f9202 ed80          	ldy	OFST-3,s
 298 f9204 2716          	beq	L521
 299                     ; 124         pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
 301 f9206 c601          	ldab	#1
 302 f9208 6b40          	stab	0,y
 303                     ; 125         pevent->OSEventCnt     = 0u;
 305 f920a 87            	clra	
 306 f920b c7            	clrb	
 307 f920c 6c43          	std	3,y
 308                     ; 126         pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
 310 f920e 18028341      	movw	OFST+0,s,1,y
 311                     ; 128         pevent->OSEventName    = (INT8U *)(void *)"?";
 313 f9212 cc770f        	ldd	#L721
 314 f9215 6c4e          	std	14,y
 315                     ; 130         OS_EventWaitListInit(pevent);
 317 f9217 b764          	tfr	y,d
 318 f9219 164701        	jsr	_OS_EventWaitListInit
 321 f921c               L521:
 322                     ; 134     return (pevent);                             /* Return pointer to event control block              */
 324 f921c ec80          	ldd	OFST-3,s
 326 f921e               L21:
 328 f921e 1b85          	leas	5,s
 329 f9220 3d            	rts	
 417                     ; 179 _NEAR OS_EVENT  *OSMboxDel (OS_EVENT  *pevent,
 417                     ; 180                            INT8U      opt,
 417                     ; 181                            INT8U     *perr)
 417                     ; 182 {
 418                     	switch	.text
 419 f9221               _OSMboxDel:
 421 f9221 3b            	pshd	
 422 f9222 1b9c          	leas	-4,s
 423       00000004      OFST:	set	4
 426                     ; 186     OS_CPU_SR  cpu_sr = 0u;
 428                     ; 207     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 430 f9224 046404        	tbne	d,L102
 431                     ; 208         *perr = OS_ERR_PEVENT_NULL;
 433 f9227 c604          	ldab	#4
 434                     ; 209         return (pevent);
 437 f9229 2009          	bra	L61
 438 f922b               L102:
 439                     ; 215     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 442 f922b e6f30004      	ldab	[OFST+0,s]
 443 f922f 04010b        	dbeq	b,L302
 444                     ; 216         *perr = OS_ERR_EVENT_TYPE;
 446 f9232 c601          	ldab	#1
 447                     ; 218         return (pevent);
 451 f9234               L61:
 452 f9234 6bf3000a      	stab	[OFST+6,s]
 453 f9238 ec84          	ldd	OFST+0,s
 455 f923a 1b86          	leas	6,s
 456 f923c 3d            	rts	
 457 f923d               L302:
 458                     ; 220     if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
 460 f923d f61631        	ldab	_OSIntNesting
 461 f9240 2704          	beq	L502
 462                     ; 221         *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 464 f9242 c60f          	ldab	#15
 465                     ; 223         return (pevent);
 469 f9244 20ee          	bra	L61
 470 f9246               L502:
 471                     ; 225     OS_ENTER_CRITICAL();
 473 f9246 167522        	jsr	_OS_CPU_SR_Save
 475 f9249 6b80          	stab	OFST-4,s
 476                     ; 226     if (pevent->OSEventGrp != 0u) {                        /* See if any tasks waiting on mailbox      */
 478 f924b ed84          	ldy	OFST+0,s
 479 f924d e645          	ldab	5,y
 480 f924f 2706          	beq	L702
 481                     ; 227         tasks_waiting = OS_TRUE;                           /* Yes                                      */
 483 f9251 c601          	ldab	#1
 484 f9253 6b83          	stab	OFST-1,s
 486 f9255 2002          	bra	L112
 487 f9257               L702:
 488                     ; 229         tasks_waiting = OS_FALSE;                          /* No                                       */
 490 f9257 6983          	clr	OFST-1,s
 491 f9259               L112:
 492                     ; 231     switch (opt) {
 494 f9259 e689          	ldab	OFST+5,s
 496 f925b 270d          	beq	L131
 497 f925d 040152        	dbeq	b,L522
 498                     ; 270         default:
 498                     ; 271              OS_EXIT_CRITICAL();
 500 f9260 e680          	ldab	OFST-4,s
 501 f9262 87            	clra	
 502 f9263 167527        	jsr	_OS_CPU_SR_Restore
 504                     ; 272              *perr         = OS_ERR_INVALID_OPT;
 506 f9266 c607          	ldab	#7
 507                     ; 273              pevent_return = pevent;
 509                     ; 274              break;
 511 f9268 202e          	bra	LC003
 512 f926a               L131:
 513                     ; 232         case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
 513                     ; 233              if (tasks_waiting == OS_FALSE) {
 515 f926a e683          	ldab	OFST-1,s
 516 f926c 2622          	bne	L712
 517                     ; 235                  pevent->OSEventName = (INT8U *)(void *)"?";
 519 f926e cc770f        	ldd	#L721
 520 f9271 6c4e          	std	14,y
 521                     ; 237                  pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 523 f9273 87            	clra	
 524 f9274 6a40          	staa	0,y
 525                     ; 238                  pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 527 f9276 18014116f7    	movw	_OSEventFreeList,1,y
 528                     ; 239                  pevent->OSEventCnt  = 0u;
 530 f927b c7            	clrb	
 531 f927c 6c43          	std	3,y
 532                     ; 240                  OSEventFreeList     = pevent;             /* Get next free event control block        */
 534 f927e 18058416f7    	movw	OFST+0,s,_OSEventFreeList
 535                     ; 241                  OS_EXIT_CRITICAL();
 537 f9283 e680          	ldab	OFST-4,s
 538 f9285 167527        	jsr	_OS_CPU_SR_Restore
 540                     ; 242                  *perr               = OS_ERR_NONE;
 542 f9288 87            	clra	
 543 f9289 6af3000a      	staa	[OFST+6,s]
 544                     ; 243                  pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
 546 f928d c7            	clrb	
 548 f928e 200e          	bra	LC002
 549 f9290               L712:
 550                     ; 245                  OS_EXIT_CRITICAL();
 552 f9290 e680          	ldab	OFST-4,s
 553 f9292 87            	clra	
 554 f9293 167527        	jsr	_OS_CPU_SR_Restore
 556                     ; 246                  *perr               = OS_ERR_TASK_WAITING;
 558 f9296 c649          	ldab	#73
 559                     ; 247                  pevent_return       = pevent;
 561 f9298               LC003:
 562 f9298 6bf3000a      	stab	[OFST+6,s]
 563 f929c ec84          	ldd	OFST+0,s
 564 f929e               LC002:
 565 f929e 6c81          	std	OFST-3,s
 566 f92a0 203c          	bra	L512
 567 f92a2               L322:
 568                     ; 253                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
 570 f92a2 cc0002        	ldd	#2
 571 f92a5 3b            	pshd	
 572 f92a6 3b            	pshd	
 573 f92a7 c7            	clrb	
 574 f92a8 3b            	pshd	
 575 f92a9 ec8a          	ldd	OFST+6,s
 576 f92ab 164554        	jsr	_OS_EventTaskRdy
 578 f92ae 1b86          	leas	6,s
 579 f92b0 ed84          	ldy	OFST+0,s
 580 f92b2               L522:
 581                     ; 251         case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
 581                     ; 252              while (pevent->OSEventGrp != 0u) {            /* Ready ALL tasks waiting for mailbox      */
 583 f92b2 e645          	ldab	5,y
 584 f92b4 26ec          	bne	L322
 585                     ; 256              pevent->OSEventName    = (INT8U *)(void *)"?";
 587 f92b6 cc770f        	ldd	#L721
 588 f92b9 6c4e          	std	14,y
 589                     ; 258              pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 591 f92bb 87            	clra	
 592 f92bc 6a40          	staa	0,y
 593                     ; 259              pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 595 f92be 18014116f7    	movw	_OSEventFreeList,1,y
 596                     ; 260              pevent->OSEventCnt     = 0u;
 598 f92c3 c7            	clrb	
 599 f92c4 6c43          	std	3,y
 600                     ; 261              OSEventFreeList        = pevent;              /* Get next free event control block        */
 602 f92c6 18058416f7    	movw	OFST+0,s,_OSEventFreeList
 603                     ; 262              OS_EXIT_CRITICAL();
 605 f92cb e680          	ldab	OFST-4,s
 606 f92cd 167527        	jsr	_OS_CPU_SR_Restore
 608                     ; 263              if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 610 f92d0 e683          	ldab	OFST-1,s
 611 f92d2 042103        	dbne	b,L132
 612                     ; 264                  OS_Sched();                               /* Find highest priority task ready to run  */
 614 f92d5 16488b        	jsr	_OS_Sched
 616 f92d8               L132:
 617                     ; 266              *perr         = OS_ERR_NONE;
 619 f92d8 87            	clra	
 620 f92d9 6af3000a      	staa	[OFST+6,s]
 621                     ; 267              pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
 623 f92dd c7            	clrb	
 624                     ; 268              break;
 626 f92de               L512:
 627                     ; 279     return (pevent_return);
 632 f92de 1b86          	leas	6,s
 633 f92e0 3d            	rts	
 712                     ; 317 _NEAR void  *OSMboxPend (OS_EVENT  *pevent,
 712                     ; 318                         INT32U     timeout,
 712                     ; 319                         INT8U     *perr)
 712                     ; 320 {
 713                     	switch	.text
 714 f92e1               _OSMboxPend:
 716 f92e1 3b            	pshd	
 717 f92e2 1b9d          	leas	-3,s
 718       00000003      OFST:	set	3
 721                     ; 323     OS_CPU_SR  cpu_sr = 0u;
 723                     ; 335     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 725 f92e4 046404        	tbne	d,L572
 726                     ; 336         *perr = OS_ERR_PEVENT_NULL;
 728 f92e7 c604          	ldab	#4
 729                     ; 337         return ((void *)0);
 732 f92e9 2009          	bra	LC004
 733 f92eb               L572:
 734                     ; 343     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 737 f92eb e6f30003      	ldab	[OFST+0,s]
 738 f92ef 04010b        	dbeq	b,L772
 739                     ; 344         *perr = OS_ERR_EVENT_TYPE;
 741 f92f2 c601          	ldab	#1
 742                     ; 346         return ((void *)0);
 745 f92f4               LC004:
 746 f92f4 6bf3000b      	stab	[OFST+8,s]
 747 f92f8 87            	clra	
 748 f92f9 c7            	clrb	
 750 f92fa               L22:
 752 f92fa 1b85          	leas	5,s
 753 f92fc 3d            	rts	
 754 f92fd               L772:
 755                     ; 348     if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
 757 f92fd f61631        	ldab	_OSIntNesting
 758 f9300 2704          	beq	L103
 759                     ; 349         *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 761 f9302 c602          	ldab	#2
 762                     ; 351         return ((void *)0);
 766 f9304 20ee          	bra	LC004
 767 f9306               L103:
 768                     ; 353     if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
 770 f9306 f61630        	ldab	_OSLockNesting
 771 f9309 2704          	beq	L303
 772                     ; 354         *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 774 f930b c60d          	ldab	#13
 775                     ; 356         return ((void *)0);
 779 f930d 20e5          	bra	LC004
 780 f930f               L303:
 781                     ; 358     OS_ENTER_CRITICAL();
 783 f930f 167522        	jsr	_OS_CPU_SR_Save
 785 f9312 6b82          	stab	OFST-1,s
 786                     ; 359     pmsg = pevent->OSEventPtr;
 788 f9314 ed83          	ldy	OFST+0,s
 789 f9316 ec41          	ldd	1,y
 790 f9318 6c80          	std	OFST-3,s
 791                     ; 360     if (pmsg != (void *)0) {                          /* See if there is already a message             */
 793 f931a 2711          	beq	L503
 794                     ; 361         pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
 796 f931c 87            	clra	
 797 f931d c7            	clrb	
 798 f931e 6c41          	std	1,y
 799                     ; 362         OS_EXIT_CRITICAL();
 801 f9320 e682          	ldab	OFST-1,s
 802 f9322 167527        	jsr	_OS_CPU_SR_Restore
 804                     ; 363         *perr = OS_ERR_NONE;
 806 f9325 69f3000b      	clr	[OFST+8,s]
 807                     ; 365         return (pmsg);                                /* Return the message received (or NULL)         */
 810 f9329 ec80          	ldd	OFST-3,s
 812 f932b 20cd          	bra	L22
 813 f932d               L503:
 814                     ; 367     OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
 816 f932d fd157d        	ldy	_OSTCBCur
 817 f9330 0ce82202      	bset	34,y,2
 818                     ; 368     OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 820 f9334 69e823        	clr	35,y
 821                     ; 369     OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
 823 f9337 ec89          	ldd	OFST+6,s
 824 f9339 6ce820        	std	32,y
 825 f933c ec87          	ldd	OFST+4,s
 826 f933e 6ce81e        	std	30,y
 827                     ; 370     OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 829 f9341 ec83          	ldd	OFST+0,s
 830 f9343 1645e8        	jsr	_OS_EventTaskWait
 832                     ; 371     OS_EXIT_CRITICAL();
 834 f9346 e682          	ldab	OFST-1,s
 835 f9348 87            	clra	
 836 f9349 167527        	jsr	_OS_CPU_SR_Restore
 838                     ; 372     OS_Sched();                                       /* Find next highest priority task ready to run  */
 840 f934c 16488b        	jsr	_OS_Sched
 842                     ; 373     OS_ENTER_CRITICAL();
 844 f934f 167522        	jsr	_OS_CPU_SR_Save
 846 f9352 6b82          	stab	OFST-1,s
 847                     ; 374     switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 849 f9354 fd157d        	ldy	_OSTCBCur
 850 f9357 e6e823        	ldab	35,y
 852 f935a 2708          	beq	L332
 853 f935c 040117        	dbeq	b,L732
 854 f935f 04010d        	dbeq	b,L532
 855 f9362 2012          	bra	L732
 856 f9364               L332:
 857                     ; 375         case OS_STAT_PEND_OK:
 857                     ; 376              pmsg =  OSTCBCur->OSTCBMsg;
 859 f9364 ece818        	ldd	24,y
 860 f9367 6c80          	std	OFST-3,s
 861                     ; 377             *perr =  OS_ERR_NONE;
 863 f9369 69f3000b      	clr	[OFST+8,s]
 864                     ; 378              break;
 866 f936d 201e          	bra	L113
 867 f936f               L532:
 868                     ; 380         case OS_STAT_PEND_ABORT:
 868                     ; 381              pmsg = (void *)0;
 870 f936f 87            	clra	
 871 f9370 6c80          	std	OFST-3,s
 872                     ; 382             *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 874 f9372 c60e          	ldab	#14
 875                     ; 383              break;
 877 f9374 2010          	bra	LC005
 878 f9376               L732:
 879                     ; 385         case OS_STAT_PEND_TO:
 879                     ; 386         default:
 879                     ; 387              OS_EventTaskRemove(OSTCBCur, pevent);
 881 f9376 ec83          	ldd	OFST+0,s
 882 f9378 3b            	pshd	
 883 f9379 b764          	tfr	y,d
 884 f937b 16468f        	jsr	_OS_EventTaskRemove
 886 f937e 1b82          	leas	2,s
 887                     ; 388              pmsg = (void *)0;
 889 f9380 87            	clra	
 890 f9381 c7            	clrb	
 891 f9382 6c80          	std	OFST-3,s
 892                     ; 389             *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 894 f9384 c60a          	ldab	#10
 895 f9386               LC005:
 896 f9386 6bf3000b      	stab	[OFST+8,s]
 897                     ; 390              break;
 899 f938a fd157d        	ldy	_OSTCBCur
 900 f938d               L113:
 901                     ; 392     OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 903 f938d c7            	clrb	
 904 f938e 6be822        	stab	34,y
 905                     ; 393     OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 907 f9391 87            	clra	
 908 f9392 6ae823        	staa	35,y
 909                     ; 394     OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 911 f9395 6ce812        	std	18,y
 912                     ; 396     OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 914 f9398 6ce814        	std	20,y
 915                     ; 397     OSTCBCur->OSTCBEventMultiRdy = (OS_EVENT  *)0;
 917 f939b 6ce816        	std	22,y
 918                     ; 399     OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 920 f939e 6ce818        	std	24,y
 921                     ; 400     OS_EXIT_CRITICAL();
 923 f93a1 e682          	ldab	OFST-1,s
 924 f93a3 167527        	jsr	_OS_CPU_SR_Restore
 926                     ; 403     return (pmsg);                                    /* Return received message                       */
 929 f93a6 ec80          	ldd	OFST-3,s
 932 f93a8 1b85          	leas	5,s
 933 f93aa 3d            	rts	
1004                     ; 440 _NEAR INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
1004                     ; 441                              INT8U      opt,
1004                     ; 442                              INT8U     *perr)
1004                     ; 443 {
1005                     	switch	.text
1006 f93ab               _OSMboxPendAbort:
1008 f93ab 3b            	pshd	
1009       00000002      OFST:	set	2
1012                     ; 446     OS_CPU_SR  cpu_sr = 0u;
1014                     ; 459     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
1016 f93ac 6cae          	std	2,-s
1017 f93ae 2604          	bne	L153
1018                     ; 460         *perr = OS_ERR_PEVENT_NULL;
1020 f93b0 c604          	ldab	#4
1021                     ; 461         return (0u);
1024 f93b2 2009          	bra	LC006
1025 f93b4               L153:
1026                     ; 464     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
1028 f93b4 e6f30002      	ldab	[OFST+0,s]
1029 f93b8 04010a        	dbeq	b,L353
1030                     ; 465         *perr = OS_ERR_EVENT_TYPE;
1032 f93bb c601          	ldab	#1
1033                     ; 466         return (0u);
1035 f93bd               LC006:
1036 f93bd 6bf30008      	stab	[OFST+6,s]
1037 f93c1 c7            	clrb	
1039 f93c2               L62:
1041 f93c2 1b84          	leas	4,s
1042 f93c4 3d            	rts	
1043 f93c5               L353:
1044                     ; 468     OS_ENTER_CRITICAL();
1046 f93c5 167522        	jsr	_OS_CPU_SR_Save
1048 f93c8 6b81          	stab	OFST-1,s
1049                     ; 469     if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
1051 f93ca ed82          	ldy	OFST+0,s
1052 f93cc e745          	tst	5,y
1053 f93ce 2746          	beq	L553
1054                     ; 470         nbr_tasks = 0u;
1056 f93d0 6980          	clr	OFST-2,s
1057                     ; 471         switch (opt) {
1059 f93d2 e687          	ldab	OFST+5,s
1061 f93d4 271d          	beq	L513
1062 f93d6 040114        	dbeq	b,L563
1063 f93d9 2018          	bra	L513
1064 f93db               L363:
1065                     ; 474                      (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
1067 f93db cc0002        	ldd	#2
1068 f93de 3b            	pshd	
1069 f93df 3b            	pshd	
1070 f93e0 c7            	clrb	
1071 f93e1 3b            	pshd	
1072 f93e2 ec88          	ldd	OFST+6,s
1073 f93e4 164554        	jsr	_OS_EventTaskRdy
1075 f93e7 1b86          	leas	6,s
1076                     ; 475                      nbr_tasks++;
1078 f93e9 6280          	inc	OFST-2,s
1079 f93eb ed82          	ldy	OFST+0,s
1080 f93ed               L563:
1081                     ; 472             case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
1081                     ; 473                  while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
1083 f93ed e645          	ldab	5,y
1084 f93ef 26ea          	bne	L363
1085                     ; 477                  break;
1087 f93f1 2010          	bra	L163
1088 f93f3               L513:
1089                     ; 479             case OS_PEND_OPT_NONE:
1089                     ; 480             default:                                       /* No,  ready HPT       waiting on mailbox  */
1089                     ; 481                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
1091 f93f3 cc0002        	ldd	#2
1092 f93f6 3b            	pshd	
1093 f93f7 3b            	pshd	
1094 f93f8 c7            	clrb	
1095 f93f9 3b            	pshd	
1096 f93fa b764          	tfr	y,d
1097 f93fc 164554        	jsr	_OS_EventTaskRdy
1099 f93ff 1b86          	leas	6,s
1100                     ; 482                  nbr_tasks++;
1102 f9401 6280          	inc	OFST-2,s
1103                     ; 483                  break;
1105 f9403               L163:
1106                     ; 485         OS_EXIT_CRITICAL();
1108 f9403 e681          	ldab	OFST-1,s
1109 f9405 87            	clra	
1110 f9406 167527        	jsr	_OS_CPU_SR_Restore
1112                     ; 486         OS_Sched();                                        /* Find HPT ready to run                    */
1114 f9409 16488b        	jsr	_OS_Sched
1116                     ; 487         *perr = OS_ERR_PEND_ABORT;
1118 f940c c60e          	ldab	#14
1119 f940e 6bf30008      	stab	[OFST+6,s]
1120                     ; 488         return (nbr_tasks);
1122 f9412 e680          	ldab	OFST-2,s
1124 f9414 20ac          	bra	L62
1125 f9416               L553:
1126                     ; 490     OS_EXIT_CRITICAL();
1128 f9416 87            	clra	
1129 f9417 167527        	jsr	_OS_CPU_SR_Restore
1131                     ; 491     *perr = OS_ERR_NONE;
1133 f941a c7            	clrb	
1134 f941b 6bf30008      	stab	[OFST+6,s]
1135                     ; 492     return (0u);                                           /* No tasks waiting on mailbox              */
1138 f941f 20a1          	bra	L62
1195                     ; 520 _NEAR INT8U  OSMboxPost (OS_EVENT  *pevent,
1195                     ; 521                         void      *pmsg)
1195                     ; 522 {
1196                     	switch	.text
1197 f9421               _OSMboxPost:
1199 f9421 3b            	pshd	
1200 f9422 37            	pshb	
1201       00000001      OFST:	set	1
1204                     ; 524     OS_CPU_SR  cpu_sr = 0u;
1206                     ; 530     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
1208 f9423 046404        	tbne	d,L714
1209                     ; 531         return (OS_ERR_PEVENT_NULL);
1211 f9426 c604          	ldab	#4
1213 f9428 2006          	bra	L23
1214 f942a               L714:
1215                     ; 533     if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
1217 f942a ec85          	ldd	OFST+4,s
1218 f942c 2605          	bne	L124
1219                     ; 534         return (OS_ERR_POST_NULL_PTR);
1221 f942e c603          	ldab	#3
1223 f9430               L23:
1225 f9430 1b83          	leas	3,s
1226 f9432 3d            	rts	
1227 f9433               L124:
1228                     ; 540     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
1231 f9433 e6f30001      	ldab	[OFST+0,s]
1232 f9437 040104        	dbeq	b,L324
1233                     ; 542         return (OS_ERR_EVENT_TYPE);
1236 f943a c601          	ldab	#1
1238 f943c 20f2          	bra	L23
1239 f943e               L324:
1240                     ; 544     OS_ENTER_CRITICAL();
1242 f943e 167522        	jsr	_OS_CPU_SR_Save
1244 f9441 6b80          	stab	OFST-1,s
1245                     ; 545     if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
1247 f9443 ed81          	ldy	OFST+0,s
1248 f9445 e645          	ldab	5,y
1249 f9447 271b          	beq	L524
1250                     ; 547         (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
1252 f9449 87            	clra	
1253 f944a c7            	clrb	
1254 f944b 3b            	pshd	
1255 f944c c602          	ldab	#2
1256 f944e 3b            	pshd	
1257 f944f ec89          	ldd	OFST+8,s
1258 f9451 3b            	pshd	
1259 f9452 b764          	tfr	y,d
1260 f9454 164554        	jsr	_OS_EventTaskRdy
1262 f9457 1b86          	leas	6,s
1263                     ; 548         OS_EXIT_CRITICAL();
1265 f9459 e680          	ldab	OFST-1,s
1266 f945b 87            	clra	
1267 f945c 167527        	jsr	_OS_CPU_SR_Restore
1269                     ; 549         OS_Sched();                                   /* Find highest priority task ready to run       */
1271 f945f 16488b        	jsr	_OS_Sched
1273                     ; 551         return (OS_ERR_NONE);
1277 f9462 2017          	bra	LC007
1278 f9464               L524:
1279                     ; 553     if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
1281 f9464 ec41          	ldd	1,y
1282 f9466 270a          	beq	L724
1283                     ; 554         OS_EXIT_CRITICAL();
1285 f9468 e680          	ldab	OFST-1,s
1286 f946a 87            	clra	
1287 f946b 167527        	jsr	_OS_CPU_SR_Restore
1289                     ; 556         return (OS_ERR_MBOX_FULL);
1292 f946e c614          	ldab	#20
1294 f9470 20be          	bra	L23
1295 f9472               L724:
1296                     ; 558     pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
1298 f9472 18028541      	movw	OFST+4,s,1,y
1299                     ; 559     OS_EXIT_CRITICAL();
1301 f9476 e680          	ldab	OFST-1,s
1302 f9478 167527        	jsr	_OS_CPU_SR_Restore
1304                     ; 561     return (OS_ERR_NONE);
1307 f947b               LC007:
1308 f947b c7            	clrb	
1310 f947c 20b2          	bra	L23
1374                     ; 599 _NEAR INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
1374                     ; 600                            void      *pmsg,
1374                     ; 601                            INT8U      opt)
1374                     ; 602 {
1375                     	switch	.text
1376 f947e               _OSMboxPostOpt:
1378 f947e 3b            	pshd	
1379 f947f 37            	pshb	
1380       00000001      OFST:	set	1
1383                     ; 604     OS_CPU_SR  cpu_sr = 0u;
1385                     ; 610     if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
1387 f9480 046404        	tbne	d,L164
1388                     ; 611         return (OS_ERR_PEVENT_NULL);
1390 f9483 c604          	ldab	#4
1392 f9485 2006          	bra	L63
1393 f9487               L164:
1394                     ; 613     if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
1396 f9487 ec85          	ldd	OFST+4,s
1397 f9489 2605          	bne	L364
1398                     ; 614         return (OS_ERR_POST_NULL_PTR);
1400 f948b c603          	ldab	#3
1402 f948d               L63:
1404 f948d 1b83          	leas	3,s
1405 f948f 3d            	rts	
1406 f9490               L364:
1407                     ; 620     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
1410 f9490 e6f30001      	ldab	[OFST+0,s]
1411 f9494 040104        	dbeq	b,L564
1412                     ; 622         return (OS_ERR_EVENT_TYPE);
1415 f9497 c601          	ldab	#1
1417 f9499 20f2          	bra	L63
1418 f949b               L564:
1419                     ; 624     OS_ENTER_CRITICAL();
1421 f949b 167522        	jsr	_OS_CPU_SR_Save
1423 f949e 6b80          	stab	OFST-1,s
1424                     ; 625     if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
1426 f94a0 ed81          	ldy	OFST+0,s
1427 f94a2 e645          	ldab	5,y
1428 f94a4 273e          	beq	L764
1429                     ; 626         if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
1431 f94a6 0f88011a      	brclr	OFST+7,s,1,L174
1433 f94aa 2014          	bra	L574
1434 f94ac               L374:
1435                     ; 628                 (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
1437 f94ac 87            	clra	
1438 f94ad c7            	clrb	
1439 f94ae 3b            	pshd	
1440 f94af c602          	ldab	#2
1441 f94b1 3b            	pshd	
1442 f94b2 ec89          	ldd	OFST+8,s
1443 f94b4 3b            	pshd	
1444 f94b5 ec87          	ldd	OFST+6,s
1445 f94b7 164554        	jsr	_OS_EventTaskRdy
1447 f94ba 1b86          	leas	6,s
1448 f94bc ed81          	ldy	OFST+0,s
1449 f94be e645          	ldab	5,y
1450 f94c0               L574:
1451                     ; 627             while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
1453 f94c0 26ea          	bne	L374
1455 f94c2 2010          	bra	L105
1456 f94c4               L174:
1457                     ; 631             (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
1459 f94c4 87            	clra	
1460 f94c5 c7            	clrb	
1461 f94c6 3b            	pshd	
1462 f94c7 c602          	ldab	#2
1463 f94c9 3b            	pshd	
1464 f94ca ec89          	ldd	OFST+8,s
1465 f94cc 3b            	pshd	
1466 f94cd b764          	tfr	y,d
1467 f94cf 164554        	jsr	_OS_EventTaskRdy
1469 f94d2 1b86          	leas	6,s
1470 f94d4               L105:
1471                     ; 633         OS_EXIT_CRITICAL();
1473 f94d4 e680          	ldab	OFST-1,s
1474 f94d6 87            	clra	
1475 f94d7 167527        	jsr	_OS_CPU_SR_Restore
1477                     ; 634         if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
1479 f94da 0e880403      	brset	OFST+7,s,4,L305
1480                     ; 635             OS_Sched();                               /* Find HPT ready to run                         */
1482 f94de 16488b        	jsr	_OS_Sched
1484 f94e1               L305:
1485                     ; 638         return (OS_ERR_NONE);
1488 f94e1 c7            	clrb	
1490 f94e2 20a9          	bra	L63
1491 f94e4               L764:
1492                     ; 640     if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
1494 f94e4 ec41          	ldd	1,y
1495 f94e6 270a          	beq	L505
1496                     ; 641         OS_EXIT_CRITICAL();
1498 f94e8 e680          	ldab	OFST-1,s
1499 f94ea 87            	clra	
1500 f94eb 167527        	jsr	_OS_CPU_SR_Restore
1502                     ; 643         return (OS_ERR_MBOX_FULL);
1505 f94ee c614          	ldab	#20
1507 f94f0 200a          	bra	L04
1508 f94f2               L505:
1509                     ; 645     pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
1511 f94f2 18028541      	movw	OFST+4,s,1,y
1512                     ; 646     OS_EXIT_CRITICAL();
1514 f94f6 e680          	ldab	OFST-1,s
1515 f94f8 167527        	jsr	_OS_CPU_SR_Restore
1517                     ; 648     return (OS_ERR_NONE);
1520 f94fb c7            	clrb	
1522 f94fc               L04:
1524 f94fc 1b83          	leas	3,s
1525 f94fe 3d            	rts	
1643                     ; 672 _NEAR INT8U  OSMboxQuery (OS_EVENT      *pevent,
1643                     ; 673                          OS_MBOX_DATA  *p_mbox_data)
1643                     ; 674 {
1644                     	switch	.text
1645 f94ff               _OSMboxQuery:
1647 f94ff 3b            	pshd	
1648 f9500 1b9a          	leas	-6,s
1649       00000006      OFST:	set	6
1652                     ; 679     OS_CPU_SR   cpu_sr = 0u;
1654                     ; 685     if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
1656 f9502 046404        	tbne	d,L765
1657                     ; 686         return (OS_ERR_PEVENT_NULL);
1659 f9505 c604          	ldab	#4
1661 f9507 2006          	bra	L44
1662 f9509               L765:
1663                     ; 688     if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
1665 f9509 ec8a          	ldd	OFST+4,s
1666 f950b 2605          	bne	L175
1667                     ; 689         return (OS_ERR_PDATA_NULL);
1669 f950d c609          	ldab	#9
1671 f950f               L44:
1673 f950f 1b88          	leas	8,s
1674 f9511 3d            	rts	
1675 f9512               L175:
1676                     ; 692     if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
1678 f9512 e6f30006      	ldab	[OFST+0,s]
1679 f9516 040104        	dbeq	b,L375
1680                     ; 693         return (OS_ERR_EVENT_TYPE);
1682 f9519 c601          	ldab	#1
1684 f951b 20f2          	bra	L44
1685 f951d               L375:
1686                     ; 695     OS_ENTER_CRITICAL();
1688 f951d 167522        	jsr	_OS_CPU_SR_Save
1690 f9520 6b85          	stab	OFST-1,s
1691                     ; 696     p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
1693 f9522 ed8a          	ldy	OFST+4,s
1694 f9524 ee86          	ldx	OFST+0,s
1695 f9526 180a054a      	movb	5,x,10,y
1696                     ; 697     psrc                    = &pevent->OSEventTbl[0];
1698 f952a ed86          	ldy	OFST+0,s
1699 f952c 1946          	leay	6,y
1700 f952e 6d81          	sty	OFST-5,s
1701                     ; 698     pdest                   = &p_mbox_data->OSEventTbl[0];
1703 f9530 ed8a          	ldy	OFST+4,s
1704 f9532 1942          	leay	2,y
1705 f9534 6d83          	sty	OFST-3,s
1706                     ; 699     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
1708 f9536 6980          	clr	OFST-6,s
1709 f9538 ee81          	ldx	OFST-5,s
1710 f953a               L575:
1711                     ; 700         *pdest++ = *psrc++;
1713 f953a 180a3070      	movb	1,x+,1,y+
1714                     ; 699     for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
1716 f953e 6280          	inc	OFST-6,s
1719 f9540 e680          	ldab	OFST-6,s
1720 f9542 c108          	cmpb	#8
1721 f9544 25f4          	blo	L575
1722 f9546 6e81          	stx	OFST-5,s
1723 f9548 6d83          	sty	OFST-3,s
1724                     ; 702     p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
1726 f954a ed86          	ldy	OFST+0,s
1727 f954c ec41          	ldd	1,y
1728 f954e 6cf3000a      	std	[OFST+4,s]
1729                     ; 703     OS_EXIT_CRITICAL();
1731 f9552 e685          	ldab	OFST-1,s
1732 f9554 87            	clra	
1733 f9555 167527        	jsr	_OS_CPU_SR_Restore
1735                     ; 704     return (OS_ERR_NONE);
1737 f9558 c7            	clrb	
1739 f9559 20b4          	bra	L44
1751                     	xref	_OS_Sched
1752                     	xref	_OS_EventWaitListInit
1753                     	xref	_OS_EventTaskRemove
1754                     	xref	_OS_EventTaskWait
1755                     	xref	_OS_EventTaskRdy
1756                     	xdef	_OSMboxQuery
1757                     	xdef	_OSMboxPostOpt
1758                     	xdef	_OSMboxPost
1759                     	xdef	_OSMboxPendAbort
1760                     	xdef	_OSMboxPend
1761                     	xdef	_OSMboxDel
1762                     	xdef	_OSMboxCreate
1763                     	xdef	_OSMboxAccept
1764                     	xref	_OSTCBCur
1765                     	xref	_OSLockNesting
1766                     	xref	_OSIntNesting
1767                     	xref	_OSEventFreeList
1768                     	xref	_OS_CPU_SR_Restore
1769                     	xref	_OS_CPU_SR_Save
1770                     .const:	section	.data
1771 fb70f               L721:
1772 fb70f 3f00          	dc.b	"?",0
1793                     	end
